.EN	Active Record Query Interface
.EN	=============================
.JA	Active Record クエリインタフェース
.JA	=====================================

.EN	This guide covers different ways to retrieve data from the database using Active Record.
.JA	本ガイドでは、Active Record を使ってデータベースからデータをとってくるさまざまな方法を説明します。

.EN	After reading this guide, you will know:
.JA	このガイドを読むことで、以下のようなことがわかるでしょう。:

.EN	* How to find records using a variety of methods and conditions.
.EN	* How to specify the order, retrieved attributes, grouping, and other properties of the found records.
.EN	* How to use eager loading to reduce the number of database queries needed for data retrieval.
.EN	* How to use dynamic finders methods.
.EN	* How to check for the existence of particular records.
.EN	* How to perform various calculations on Active Record models.
.EN	* How to run EXPLAIN on relations.
.JA	* いろんなメソッドや条件を使ってレコードを検索する方法
.JA	* 検索できたレコードの順番や、抽出するカラムや、グルーピングなどのプロパティを指定する方法
.JA	* Eager loading を使うことで、データの抽出に必要なデータベースクエリの数を減らす方法
.JA	* 動的finderメソッドを使う方法
.JA	* 特定のレコードについて存在するかどうかを調べる方法
.JA	* Active Record モデルで様々な計算を実行する方法
.JA	* 関連で EXPLAIN を走らせる方法

--------------------------------------------------------------------------------

.EN	If you're used to using raw SQL to find database records, then you will generally find that there are better ways to carry out the same operations in Rails. Active Record insulates you from the need to use SQL in most cases.
.JA	もし生のSQLを使ってデータベースレコードを検索しているなら、Rails で同じことするにはもっと良い方法があるのだと大体わかるでしょう。Active Record を使えばほとんどの場合においてSQLを使う必要はありません。

.EN	Code examples throughout this guide will refer to one or more of the following models:
.JA	本ガイドに登場するコード例では、次のようなモデルを使います:

.EN	TIP: All of the following models use `id` as the primary key, unless specified otherwise.
.JA	TIP: 以下に示すモデルはすべて、特に指定がない限りは主キーとして `id` を使います。

	```ruby
	class Client < ActiveRecord::Base
	  has_one :address
	  has_many :orders
	  has_and_belongs_to_many :roles
	end
	```

	```ruby
	class Address < ActiveRecord::Base
	  belongs_to :client
	end
	```

	```ruby
	class Order < ActiveRecord::Base
	  belongs_to :client, counter_cache: true
	end
	```

	```ruby
	class Role < ActiveRecord::Base
	  has_and_belongs_to_many :clients
	end
	```

.EN	Active Record will perform queries on the database for you and is compatible with most database systems (MySQL, PostgreSQL and SQLite to name a few). Regardless of which database system you're using, the Active Record method format will always be the same.
.JA	Active Record はデータベースに対してクエリを実行します。また Active Record はほとんどのデータベースシステム (いくつか例を挙げますと MySQL や PostgreSQL や SQLite) で互換性があります。どのデータベースシステムを使おうとも、Active Record のメソッド形式はつねに同じです。

.EN	Retrieving Objects from the Database
.EN	------------------------------------
.JA	h3. デーベースから 1 件取り出す

.EN	To retrieve objects from the database, Active Record provides several finder methods. Each finder method allows you to pass arguments into it to perform certain queries on your database without writing raw SQL.
.JA	データベースからオブジェクトを取り出すために、Active Record は検索用メソッドをいくつか用意しています。それぞれのファインダメソッドに引数を渡すことで、生のSQLを書くことなしに、データベースに対して特定のクエリを実行することができます。

.EN	The methods are:
.JA	そのためのメソッドがこちらです:

	* `bind`
	* `create_with`
	* `eager_load`
	* `extending`
	* `from`
	* `group`
	* `having`
	* `includes`
	* `joins`
	* `limit`
	* `lock`
	* `none`
	* `offset`
	* `order`
	* `preload`
	* `readonly`
	* `references`
	* `reorder`
	* `reverse_order`
	* `select`
	* `uniq`
	* `where`

.EN	All of the above methods return an instance of `ActiveRecord::Relation`.
.JA	上記のメソッドはどれも `ActiveRecord::Relation` のインスタンスを返します。

.EN	The primary operation of `Model.find(options)` can be summarized as:
.JA	`Model.find(options)` の主な操作をまとめると:

.EN	* Convert the supplied options to an equivalent SQL query.
.EN	* Fire the SQL query and retrieve the corresponding results from the database.
.EN	* Instantiate the equivalent Ruby object of the appropriate model for every resulting row.
.EN	* Run `after_find` callbacks, if any.
.JA	* 与えられたオプションを同等の SQL クエリに変換すること。
.JA	* SQL クエリを実行し、対応する結果をデータベースから抽出すること。
.JA	* 各行に応じたモデルの Ruby オブジェクトを作成すること。
.JA	* もしあれば after_find コールバックを呼び出すこと。

.EN	### Retrieving a Single Object
.JA	### オブジェクトをひとつ取り出す

.EN	Active Record provides five different ways of retrieving a single object.
.JA	Active Record は、オブジェクトをひとつ取り出す方法を 5 つ用意しています。

.EN	#### Using a Primary Key
.JA	#### 主キーを使う

.EN	Using `Model.find(primary_key)`, you can retrieve the object corresponding to the specified _primary key_ that matches any supplied options. For example:
.JA	`Model.find(primary_key`) を使うことで、 _primary key_ に対応したオブジェクトやオプションに一致したオブジェクトを取り出せます。たとえば:

	```ruby
.EN	# Find the client with primary key (id) 10.
.JA	# 主キー (id) が 10 である顧客を検索する
	client = Client.find(10)
	# => #<Client id: 10, first_name: "Ryan">
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQl は:

	```sql
	SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
	```

.EN	`Model.find(primary_key)` will raise an `ActiveRecord::RecordNotFound` exception if no matching record is found.
.JA	`Model.find(primary_key)` は、もし該当するレコードが見つからなければ、`ActiveRecord::RecordNotFound` 例外を発生させます。

.EN	#### `take`
.JA	#### `take`

.EN	`Model.take` retrieves a record without any implicit ordering. For example:
.JA	`Model.take` は、順番を関係なしにひとつのレコードを取り出します。たとえば:

	```ruby
	client = Client.take
	# => #<Client id: 1, first_name: "Lifo">
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients LIMIT 1
	```

.EN	`Model.take` returns `nil` if no record is found and no exception will be raised.
.JA	`Model.take` は、レコードがひとつも見つけられなくても例外は発生しません。

.EN	TIP: The retrieved record may vary depending on the database engine.
.JA	TIP: レコードを取り出すことはデータベースエニジンによって動作が変わることがあります。

.EN	#### `first`
.JA	#### `first`

.EN	`Model.first` finds the first record ordered by the primary key. For example:
.JA	`Model.first` は、主キーで並べたときの最初のレコードを返します。たとえば:

	```ruby
	client = Client.first
	# => #<Client id: 1, first_name: "Lifo">
	```

.EN	The SQL equivalent of the above is:
.JA	これに同等の SQL は:

	```sql
	SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
	```

.EN	`Model.first` returns `nil` if no matching record is found and no exception will be raised.
.JA	`Model.first` は、一致するレコードがなければ nil を返します。例外は発生しません。

.EN	#### `last`
.JA	#### `last`

.EN	`Model.last` finds the last record ordered by the primary key. For example:
.JA	`Model.last` は、主キーで並べたときの最後のレコードを返します。たとえば:

	```ruby
	client = Client.last
	# => #<Client id: 221, first_name: "Russel">
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
	```

.EN	`Model.last` returns `nil` if no matching record is found and no exception will be raised.
.JA	`Model.last` は、もし一致するレコードがなければ `nil` を返します。例外は発生しません。

.EN	#### `find_by`
.JA	#### `find_by`

.EN	`Model.find_by` finds the first record matching some conditions. For example:
.JA	`Model.find_by` は、いくつかの条件に一致する最初のレコードを見つけます。たとえば:

	```ruby
	Client.find_by first_name: 'Lifo'
	# => #<Client id: 1, first_name: "Lifo">

	Client.find_by first_name: 'Jon'
	# => nil
	```

.EN	It is equivalent to writing:
.JA	これは以下の書き方と同じです。

	```ruby
	Client.where(first_name: 'Lifo').take
	```

.EN	#### `take!`
.JA	#### `take!`

.EN	`Model.take!` retrieves a record without any implicit ordering. For example:
.JA	`Model.take!` は、順番を関係なしにひとつのレコードを取り出します。たとえば:

	```ruby
	client = Client.take!
	# => #<Client id: 1, first_name: "Lifo">
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients LIMIT 1
	```

.EN	`Model.take!` raises `ActiveRecord::RecordNotFound` if no matching record is found.
.JA	`Model.take!` は一致するレコードがなければ、`ActiveRecord::RecordNotFound` が発生します。

.EN	#### `first!`
.JA	#### `first!`

.EN	`Model.first!` finds the first record ordered by the primary key. For example:
.JA	`Model.first!` は、主キーで並べたときの最初のレコードを返します。たとえば:

	```ruby
	client = Client.first!
	# => #<Client id: 1, first_name: "Lifo">
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
	```

.EN	`Model.first!` raises `ActiveRecord::RecordNotFound` if no matching record is found.
.JA	`Model.first!` は一致するレコードがなければ、`ActiveRecord::RecordNotFound` が発生します。

.EN	#### `last!`
.JA	#### `last!`

.EN	`Model.last!` finds the last record ordered by the primary key. For example:
.JA	`Model.last!` は、主キーで並べた最後のレコードを返します。たとえば:

	```ruby
	client = Client.last!
	# => #<Client id: 221, first_name: "Russel">
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は

	```sql
	SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
	```

.EN	`Model.last!` raises `ActiveRecord::RecordNotFound` if no matching record is found.
.JA	`Model.last!` は一致するレコードがなければ、`ActiveRecord:RecordNotFound` が発生します。

.EN	#### `find_by!`
.JA	#### `find_by!`

.EN	`Model.find_by!` finds the first record matching some conditions. It raises `ActiveRecord::RecordNotFound` if no matching record is found. For example:
.JA	`Model.find_by` 条件に一致する最初のレコードを返します。もし一致するレコードがなければ、`ActiveRecord::RecordNotFound` が発生します。

	```ruby
	Client.find_by! first_name: 'Lifo'
	# => #<Client id: 1, first_name: "Lifo">

	Client.find_by! first_name: 'Jon'
	# => ActiveRecord::RecordNotFound
	```

.EN	It is equivalent to writing:
.JA	これはこのように書くのと同じです。

	```ruby
	Client.where(first_name: 'Lifo').take!
	```

.EN	### Retrieving Multiple Objects
.JA	### 複数のオブジェクトを取り出す

.EN	#### Using Multiple Primary Keys
.JA	#### 複数の主キーを使う

.EN	`Model.find(array_of_primary_key)` accepts an array of _primary keys_, returning an array containing all of the matching records for the supplied _primary keys_. For example:
.JA	`Model.find(array_of_primary_key)` は、引数として _primary keys_ の配列を取ることができます。この場合、指定された _primary keys_ にマッチしたレコードを含んだ配列を返します。たとえば:

	```ruby
.EN	# Find the clients with primary keys 1 and 10.
.JA	# 主キーが 1 と 10 の顧客を検索する
	client = Client.find([1, 10]) # Or even Client.find(1, 10)
	# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, first_name: "Ryan">]
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients WHERE (clients.id IN (1,10))
	```

.EN	WARNING: `Model.find(array_of_primary_key)` will raise an `ActiveRecord::RecordNotFound` exception unless a matching record is found for **all** of the supplied primary keys.
.JA	WARNING: `Model.find(array_of_primary_key)` は、指定された主キーにマッチするレコードが**ひとつでも**見つからない場合は、`ActiveRecord::RecordNotFound` 例外を発生させます〔訳注: すべて見つかった場合のみ例外は発生しない〕。

	#### take

.EN	`Model.take(limit)` retrieves the first number of records specified by `limit` without any explicit ordering:
.JA	`Model.take(limit)` は、並び換えを行なわず `limit` に指定した数だけ最初のレコードを返します。:

	```ruby
	Client.take(2)
	# => [#<Client id: 1, first_name: "Lifo">,
	      #<Client id: 2, first_name: "Raf">]
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients LIMIT 2
	```

.EN	#### first

.EN	`Model.first(limit)` finds the first number of records specified by `limit` ordered by primary key:
.JA	`Model.first(limit)` 主キーによって並び換えをして `limit` に指定した数だけのレコードを返します。

	```ruby
	Client.first(2)
	# => [#<Client id: 1, first_name: "Lifo">,
	      #<Client id: 2, first_name: "Raf">]
	```

.EN	The SQL equivalent of the above is:
.JA	これと同等の SQL は:

	```sql
	SELECT * FROM clients ORDER BY id ASC LIMIT 2
	```

	#### last

.EN	`Model.last(limit)` finds the number of records specified by `limit` ordered by primary key in descending order:
.JA	`Model.last(limit)` は、主キーの逆順の順番で `limit` に指定された数だけのレコードを返します。

	```ruby
	Client.last(2)
	# => [#<Client id: 10, first_name: "Ryan">,
      #<Client id: 9, first_name: "John">]
```

.EN	The SQL equivalent of the above is:

	```sql
	SELECT * FROM clients ORDER BY id DESC LIMIT 2
	```

.EN	### Retrieving Multiple Objects in Batches
.JA	### 複数のオブジェクトをバッチ方式で取り出す

.EN	We often need to iterate over a large set of records, as when we send a newsletter to a large set of users, or when we export data.
.JA	たびたび非常にたくさんのレコードに対して繰り返し行わなければならいことがあります。全ユーザに対してニュースレターを送信する場合や、データをエクスポートする場合です。

.EN	This may appear straightforward:
.JA	これは素直な方法だと思うかもしれません:

	```ruby
.EN	# This is very inefficient when the users table has thousands of rows.
.JA	# users テーブルが数千行ある場合はとても効率が悪いです。
	User.all.each do |user|
	  NewsLetter.weekly_deliver(user)
	end
	```

.EN	But this approach becomes increasingly impractical as the table size increases, since `User.all.each` instructs Active Record to fetch _the entire table_ in a single pass, build a model object per row, and then keep the entire array of model objects in memory. Indeed, if we have a large number of records, the entire collection may exceed the amount of memory available.
.JA	この方法はテーブルのサイズが増加していくと、次第に実用的ではなくなります。`User.all.each` は一度に__テーブル全体__を取得するように ActiveRecord へ指示するので、行の数だけモデルオブジェクが構築されてしまい、メモリ上にすべてのモデルオブジェクト配列が保存されます。非常にたくさんのレコードがあれば、実際にはコレクション全体の大きさは利用可能なメモリを越えてしまうかもしれません。

.EN	Rails provides two methods that address this problem by dividing records into memory-friendly batches for processing. The first method, `find_each`, retrieves a batch of records and then yields _each_ record to the block individually as a model. The second method, `find_in_batches`, retrieves a batch of records and then yields _the entire batch_ to the block as an array of models.
.JA	Rails は、この問題を解決するのにレコードを分けて、メモリに優しくなるような処理単位にするメソッドを二つ用意しています。ひとつめは `find_each`で、レコードのまとまりを取り出し、そして、ひとつのモデルを個別にブロックへを渡します。ふたつめは `find_in_batches` で、_バッチ全体_を一つのモデルの配列にしてブロックヘ渡します。

.EN	TIP: The `find_each` and `find_in_batches` methods are intended for use in the batch processing of a large number of records that wouldn't fit in memory all at once. If you just need to loop over a thousand records the regular find methods are the preferred option.
.JA	TIP: `find_each` と `find_in_batches` メソッドはは、一度にメモリに収まりきれない非常にたくさんのレコードを一括処理させる目的があります。もし望むオプションでファインドメソッドを利用して、幾千ものレコードがあるときにループするのに良いです。

.EN	#### `find_each`
.JA	#### `find_each`

.EN	The `find_each` method retrieves a batch of records and then yields _each_ record to the block individually as a model. In the following example, `find_each` will retrieve 1000 records (the current default for both `find_each` and `find_in_batches`) and then yield each record individually to the block as a model. This process is repeated until all of the records have been processed:
.JA	`find_each` メソッドはレコードのまとまりを取り出して、個々のモデルに対しブロックをひとつひとつ呼び出します。以下の例は、`find~each` は1000 レコード(`find~each`と`find_in_batches`ともに現在デフォルトになっている) 取り出します。 そして 個々のモデルに対しブロックをひとつひとつ呼び出します。. この処理はすべてのレコードを処理し終えるまで繰りかえされます。

	```ruby
	User.find_each do |user|
	  NewsLetter.weekly_deliver(user)
	end
	```

.EN	##### Options for `find_each`
.JA	##### `find_each` のオプション

.EN	The `find_each` method accepts most of the options allowed by the regular `find` method, except for `:order` and `:limit`, which are reserved for internal use by `find_each`.
.JA	`find_each` メソッドは なじみの `find`メソッドで利用できるいろいろなオプションが利用できます。`:order` と `:limit` は例外で、`find_each` の内部で予約されています。

.EN	Two additional options, `:batch_size` and `:start`, are available as well.
.JA	ふたつの追加オプションがあり、 `:batch_size`と `:start` が利用できます。

	**`:batch_size`**

.EN	The `:batch_size` option allows you to specify the number of records to be retrieved in each batch, before being passed individually to the block. For example, to retrieve records in batches of 5000:
.JA	`:batch_size` オブションは取り出すレコードの数を指定するのに利用できます。例では 一度に 5000 レコード取り出しています。

	```ruby
	User.find_each(batch_size: 5000) do |user|
	  NewsLetter.weekly_deliver(user)
	end
	```

	**`:start`**

.EN	By default, records are fetched in ascending order of the primary key, which must be an integer. The `:start` option allows you to configure the first ID of the sequence whenever the lowest ID is not the one you need. This would be useful, for example, if you wanted to resume an interrupted batch process, provided you saved the last processed ID as a checkpoint.
.JA	デフォルトでは、レコードは主キーの昇順でフェッチされます。主キーは整数でなければなりません。番号の小さいものは必要としない場合、 `:start` オプションを使えば、取り出すべき一連のレコードにおける最初の ID を設定できます。これは、たとえばバッチ処理が中断された場合に、最後に処理したレコードの ID をチェックポイントとして保存しておき、あとでその ID から処理を再開するような場合に役に立ちます。

.EN	For example, to send newsletters only to users with the primary key starting from 2000, and to retrieve them in batches of 5000:
.JA	例えば、主キーが `2000` 以降のユーザにだけニュースレターを送信する場合は:

	```ruby
	User.find_each(start: 2000, batch_size: 5000) do |user|
	  NewsLetter.weekly_deliver(user)
	end
	```

.EN	Another example would be if you wanted multiple workers handling the same processing queue. You could have each worker handle 10000 records by setting the appropriate `:start` option on each worker.
.JA	別の例として、同じプロセスキューで複数のワーカで処理したいとします。それそれのワーカに `:start`オプションを適切に設定することでそれぞれのワーか 10000 レコード処理できます。(訳注:10000という数値はどこかかきたのだろう)

.EN	#### `find_in_batches`
.JA	#### `find_in_batches`

.EN	The `find_in_batches` method is similar to `find_each`, since both retrieve batches of records. The difference is that `find_in_batches` yields _batches_ to the block as an array of models, instead of individually. The following example will yield to the supplied block an array of up to 1000 invoices at a time, with the final block containing any remaining invoices:
.JA	`find_in_batches` メソッドは `find_eahc` に似ていて、 両方ともレコードの固まりを取り出します。違いは `finde_in_batche` _固まり_をモデルの配列としてブロックに渡します。次の例は 1000のインボイスの配列がブロックに提供されて呼び出され、最後のブロックには残りのインボイスが渡されます。

	```ruby
.EN	# Give add_invoices an array of 1000 invoices at a time
.JA	# add_invoicesには 1度に 1000件のインボイスの配列が与えられます
	Invoice.find_in_batches(include: :invoice_lines) do |invoices|
	  export.add_invoices(invoices)
	end
	```

.EN	NOTE: The `:include` option allows you to name associations that should be loaded alongside with the models.
.JA	NOTE: `:include` オプションは一緒に読みこむべきモデルの関連名を指定します。

.EN	##### Options for `find_in_batches`
.JA	##### `find_in_batechs` のオプション

.EN	The `find_in_batches` method accepts the same `:batch_size` and `:start` options as `find_each`, as well as most of the options allowed by the regular `find` method, except for `:order` and `:limit`, which are reserved for internal use by `find_in_batches`.
.JA	`find_in_batches` メソッドは `find_each` のオプションと同じ `:batch_size` と `:start`を指定できます。同様に 一般的な `find`メソッドのほとんどのオプションが指定できますが、`:order` と `:limit`は例外で、`find in_batches` の内部でしようするために予約されています。

.EN	Conditions
.EN	----------
.JA	検索条件
.JA	--------

.EN	The `where` method allows you to specify conditions to limit the records returned, representing the `WHERE`-part of the SQL statement. Conditions can either be specified as a string, array, or hash.
.JA	`where` メソッドでは、返されるレコードを限定するための検索条件を指定できます。これは SQL 文でいうところの WHERE 句で表されます。条件は文字列や配列やハッシュで指定できます。

.EN	### Pure String Conditions
.JA	### 文字列だけを使った検索条件

.EN	If you'd like to add conditions to your find, you could just specify them in there, just like `Client.where("orders_count = '2'")`. This will find all clients where the `orders_count` field's value is 2.
.JA	もし find に検索条件を追加するなら、それをたとえば `Client.where("orders_count = '2'")` のようにその場で指定でき、この場合なら `orders_count` フィールドの値が 2 であるようなクライアントをすべて検索します。

.EN	WARNING: Building your own conditions as pure strings can leave you vulnerable to SQL injection exploits. For example, `Client.where("first_name LIKE '%#{params[:first_name]}%'")` is not safe. See the next section for the preferred way to handle conditions using an array.
.JA	警告: 条件を文字列だけで組み立てるのは、SQL インジェクションの脆弱性を残してしまう危険性が高いです。たとえば `Client.where("first_name LIKE '%#{params[:first_name]}%'")` は安全ではありません。次のセクションで、配列を使って検索条件を構築するという、より好ましい方法を説明します。

.EN	### Array Conditions
.JA	### 配列を使った検索条件

.EN	Now what if that number could vary, say as an argument from somewhere? The find would then take the form:
.JA	たとえば何かの引数をもとにしたり、数値が変化するような場合はどうするのでしょう? この形式にして見つけます:

	```ruby
	Client.where("orders_count = ?", params[:orders])
	```

.EN	Active Record will go through the first element in the conditions value and any additional elements will replace the question marks `(?)` in the first element.
.JA	Active Record は条件値の最初の要素を取り出し、その中のクエスチョンマーク `(?)` を残りの要素で置き換えます。

.EN	If you want to specify multiple conditions:
.JA	もし 複数の条件をしていしたいなら:

	```ruby
	Client.where("orders_count = ? AND locked = ?", params[:orders], false)
	```

.EN	In this example, the first question mark will be replaced with the value in `params[:orders]` and the second will be replaced with the SQL representation of `false`, which depends on the adapter.
.JA	この例では、1 つ目のクエスチョンマークは `params[:orders]` の値で置き換わり、2 つ目は `false` の SQL 的表現 (これはアダプタごとに異なります) で置き換わります。

.EN	This code is highly preferable:
.JA	〔訳注: 「?」を使った書き方は〕このコードはすごく好まれます:

.EN	```ruby
.EN	Client.where("orders_count = ?", params[:orders])
.EN	```

.EN	to this code:
.JA	〔訳注: 「#{}」を使った〕このコードに比べてです:

.EN	```ruby
.EN	Client.where("orders_count = #{params[:orders]}")
.EN	```

.EN	because of argument safety. Putting the variable directly into the conditions string will pass the variable to the database **as-is**. This means that it will be an unescaped variable directly from a user who may have malicious intent. If you do this, you put your entire database at risk because once a user finds out he or she can exploit your database they can do just about anything to it. Never ever put your arguments directly inside the conditions string.
.JA	安全性の点において望ましいといえます。条件式の文字列に値を直接埋め込むと、値をデータベースに *そのままの形で* 渡してしまいます。これはつまり、その値というのが、悪意を持ったユーザによるエスケープされてない値である可能性があるということです。もしそうなった場合、悪意を持ったユーザがその弱点を見つけてしまえば、それを突いてデータベースに対して何でもできてしまうため、データベース全体が危険に晒されてしまいます。条件式の文字列に引数を直接埋め込むようなことは決してしてはいけません。

.EN	TIP: For more information on the dangers of SQL injection, see the [Ruby on Rails Security Guide](security.html#sql-injection).
.JA	TIP: SQL インジェクションの危険性についてのより詳しい情報は、[Ruby on Rails Security Guide](security.html#sql-injection) を参照してください。

.EN	#### Placeholder Conditions
.JA	#### プレースホルダを使った検索条件

.EN	Similar to the `(?)` replacement style of params, you can also specify keys/values hash in your array conditions:
.JA	「 `?` 」を使った置換と似たような方法として、配列の条件式にハッシュのキーと値で指定することもできます:

	```ruby
	Client.where("created_at >= :start_date AND created_at <= :end_date",
	  {start_date: params[:start_date], end_date: params[:end_date]})
	```

.EN	This makes for clearer readability if you have a large number of variable conditions.
.JA	この方法は、条件式の可変部が多い場合は可読性がより高くなります。

.EN	### Hash Conditions
.JA	### ハッシュを使った検索条件

.EN	Active Record also allows you to pass in hash conditions which can increase the readability of your conditions syntax. With hash conditions, you pass in a hash with keys of the fields you want conditionalised and the values of how you want to conditionalise them:
.JA	Active Record では、Hash による検索条件 (Hash Conditions) を使うことができます。これを使うと、条件式の可読性が向上します。Hash による検索条件を使うことで、条件式で使いたいフィールド名をキーとし、条件として使いたい値を Hash の値に指定できます:

.EN	NOTE: Only equality, range and subset checking are possible with Hash conditions.
.JA	NOTE: 同様に、範囲式やサブセットチェック (subset checking)〔訳注: ???〕も Hash による検索条件で利用可能です。

.EN	#### Equality Conditions
.JA	#### 等号による検索条件

	```ruby
	Client.where(locked: true)
	```

.EN	The field name can also be a string:
.JA	フィールド名は String でもよいです。

	```ruby
	Client.where('locked' => true)
	```

.EN	In the case of a belongs_to relationship, an association key can be used to specify the model if an Active Record object is used as the value. This method works with polymorphic relationships as well.

	```ruby
	Post.where(author: author)
	Author.joins(:posts).where(posts: {author: author})
	```

.EN	NOTE: The values cannot be symbols. For example, you cannot do `Client.where(status: :active)`.

#### Range Conditions

	```ruby
	Client.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
	```

.EN	This will find all clients created yesterday by using a `BETWEEN` SQL statement:
.JA	この場合だと、昨日作成されたすべての顧客情報を、SQL 文の BETWEEN を使って検索します:

	```sql
	SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
	```

.EN	This demonstrates a shorter syntax for the examples in [Array Conditions](#array-conditions)
.JA	このデモンストレーションは、配列による検索条件よりも短く書ける例となっています。

.EN	#### Subset Conditions
.JA	#### 部分集合による検索条件

.EN	If you want to find records using the `IN` expression you can pass an array to the conditions hash:
.JA	もし `IN` 演算子を使ってレコードを検索したいなら、ハッシュの値に配列を渡せばよいです:

	```ruby
	Client.where(orders_count: [1,3,5])
	```

.EN	This code will generate SQL like this:
.JA	この場合なら次のような SQL が生成されます:

	```sql
	SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
	```

.EN	### NOT Conditions

.EN	`NOT` SQL queries can be built by `where.not`.

	```ruby
	Post.where.not(author: author)
	```

.EN	In other words, this query can be generated by calling `where` with no argument, then immediately chain with `not` passing `where` conditions.

.EN	Ordering
.EN	--------
.JA	順序
.JA	----

.EN	To retrieve records from the database in a specific order, you can use the `order` method.
.JA	データベースからある特定の順番でレコードを抽出するには、 `order` メソッドを使用します。

.EN	For example, if you're getting a set of records and want to order them in ascending order by the `created_at` field in your table:
.JA	たとえば、`created_at` フィールドの昇順でテーブルからレコードを取り出したいなら:

	```ruby
	Client.order("created_at")
	```

.EN	You could specify `ASC` or `DESC` as well:
.JA	ASC〔訳注: 昇順〕または DESC〔訳注: 降順〕を指定できます:

	```ruby
	Client.order("created_at DESC")
.EN	# OR
.JA	# または
	Client.order("created_at ASC")
	```

.EN	Or ordering by multiple fields:
.JA	あるいは複数のフィールドを指定して:

	```ruby
	Client.order("orders_count ASC, created_at DESC")
	# OR
	Client.order("orders_count ASC", "created_at DESC")
	```

.EN	If you want to call `order` multiple times e.g. in different context, new order will prepend previous one

	```ruby
	Client.order("orders_count ASC").order("created_at DESC")
	# SELECT * FROM clients ORDER BY created_at DESC, orders_count ASC
	```

.EN	Selecting Specific Fields
.EN	-------------------------
.JA	特定のフィールドだけを選択する
.JA	--------------------------------

.EN	By default, `Model.find` selects all the fields from the result set using `select *`.
.JA	デフォルトでは、`Model.find` は `select *`を使って結果セット (result set) からすべてのフィールドを選択します。

.EN	To select only a subset of fields from the result set, you can specify the subset via the `select` method.
.JA	結果セットから一部のフィールドだけを取り出すには、select メソッドでフィールド名を指定する必要があります。

.EN	For example, to select only `viewable_by` and `locked` columns:
.JA	たとえば、 `viewable_by` カラムと `locked` カラムのみを選択するには:

	```ruby
	Client.select("viewable_by, locked")
	```

.EN	The SQL query used by this find call will be somewhat like:
.JA	この find メソッド呼び出しによって生成される SQL クエリはだいたい次の通りです:

	```sql
	SELECT viewable_by, locked FROM clients
	```

.EN	Be careful because this also means you're initializing a model object with only the fields that you've selected. If you attempt to access a field that is not in the initialized record you'll receive:
.JA	モデルオブジェクトのうち、指定されたフィールドのみが初期化されることに注意してください。もし初期化されてないフィールドにアクセスすると、次のようなエラーになります:

	```bash
	ActiveModel::MissingAttributeError: missing attribute: <attribute>
	```

.EN	Where `<attribute>` is the attribute you asked for. The `id` method will not raise the `ActiveRecord::MissingAttributeError`, so just be careful when working with associations because they need the `id` method to function properly.
.JA	ここで `<attribute>` はアクセスしようとしている属性です。`id` メソッドは `ActiveRecord::MissingAttributeError` を発生させませんが、アソシエーションは id メソッドが正しく機能することが必要なので、 `id` メソッドを使う場合は注意してください。

.EN	If you would like to only grab a single record per unique value in a certain field, you can use `uniq`:
.JA	フィールドにおける一意な値ごとに 1つのレコードのみを撮り出したいなら、`uniq を使用することができます:

	```ruby
	Client.select(:name).uniq
	```

.EN	This would generate SQL like:
.JA	このような SQL を生成します:

	```sql
	SELECT DISTINCT name FROM clients
	```

.EN	You can also remove the uniqueness constraint:
.JA	ユニーク制約を外すこともできます:

	```ruby
	query = Client.select(:name).uniq
	# => Returns unique names

	query.uniq(false)
	# => Returns all names, even if there are duplicates
	```

.EN	Limit and Offset
.EN	----------------
.JA	Limit と Offset
.JA	---------------

.EN	To apply `LIMIT` to the SQL fired by the `Model.find`, you can specify the `LIMIT` using `limit` and `offset` methods on the relation.
.JA	`Model.find` メソッドで SQL フィールドに `LIMIT` を適用するには、`limit` および `offset` メソッドをリレーションに指定します。

.EN	You can use `limit` to specify the number of records to be retrieved, and use `offset` to specify the number of records to skip before starting to return the records. For example
.JA	取り出しをするレコードの数を指定するために `limit` を使用することができ、返すレコードをスタート場所までスキップするレコードの数を指定するのに `offset`を使用することができます。例えば

	```ruby
	Client.limit(5)
	```

.EN	will return a maximum of 5 clients and because it specifies no offset it will return the first 5 in the table. The SQL it executes looks like this:
.JA	最大で 5 個の Client オブジェクトを返します。また offset オプションが指定されてないので、テーブルの最初から数えて 5 番目までを返します。上のコードは次のような SQL を実行します:

	```sql
	SELECT * FROM clients LIMIT 5
	```

.EN	Adding `offset` to that
.JA	これに `offest` を追加します

	```ruby
	Client.limit(5).offset(30)
	```

.EN	will return instead a maximum of 5 clients beginning with the 31st. The SQL looks like:
.JA	31番目から始めて、最大で 5 個の Client オブジェクトを返します。SQL は次の通りです。

	```sql
	SELECT * FROM clients LIMIT 5 OFFSET 30
	```

.EN	Group
.EN	-----
.JA	Group
.JA	-----

.EN	To apply a `GROUP BY` clause to the SQL fired by the finder, you can specify the `group` method on the find.
.JA	検索用メソッドで実行される SQL に `GROUP BY` を適用するには、 `group` メソッドを指定します。

.EN	For example, if you want to find a collection of the dates orders were created on:
.JA	たとえば、すべての日付を取り出し、かつ日付順でソートしたい場合:

	```ruby
	Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")
	```

.EN	And this will give you a single `Order` object for each date where there are orders in the database.
.JA	この場合なら、データベース内の日付順で、各日付ごとに `Order` オブジェクトをひとつ返します。

.EN	The SQL that would be executed would be something like this:
.JA	実行される SQL は次のようなものになります:

	```sql
	SELECT date(created_at) as ordered_date, sum(price) as total_price
	FROM orders
	GROUP BY date(created_at)
	```

.EN	Having
.EN	------
.JA	Having
.JA	------

.EN	SQL uses the `HAVING` clause to specify conditions on the `GROUP BY` fields. You can add the `HAVING` clause to the SQL fired by the `Model.find` by adding the `:having` option to the find.
.JA	`GROUP BY` で指定したフィールドに対する条件は、SQL では `HAVING` 句を追加します。 `Model.find` の `:having` オプションを使うと、SQL での `HAVING` 句を指定できます。

.EN	For example:
.JA	たとえば:

	```ruby
	Order.select("date(created_at) as ordered_date, sum(price) as total_price").
	  group("date(created_at)").having("sum(price) > ?", 100)
	```

.EN	The SQL that would be executed would be something like this:
.JA	実行される SQL は次のようなものになります:

	```sql
	SELECT date(created_at) as ordered_date, sum(price) as total_price
	FROM orders
	GROUP BY date(created_at)
	HAVING sum(price) > 100
	```

.EN	This will return single order objects for each day, but only those that are ordered more than $100 in a day.
.JA	この例だと各日付ごとに Order オブジェクトをひとつ返しますが、1日あたりの合計額が 100 より大きい場合のみです。

.EN	Overriding Conditions
.EN	---------------------

.EN	### `except`

.EN	You can specify certain conditions to be excepted by using the `except` method. For example:

	```ruby
	Post.where('id > 10').limit(20).order('id asc').except(:order)
	```

	The SQL that would be executed:

	```sql
	SELECT * FROM posts WHERE id > 10 LIMIT 20
	```

	### `unscope`

	The `except` method does not work when the relation is merged. For example:

	```ruby
	Post.comments.except(:order)
	```

	will still have an order if the order comes from a default scope on Comment. In order to remove all ordering, even from relations which are merged in, use unscope as follows:

	```ruby
	Post.order('id DESC').limit(20).unscope(:order) = Post.limit(20)
	Post.order('id DESC').limit(20).unscope(:order, :limit) = Post.all
	```

	You can additionally unscope specific where clauses. For example:

	```ruby
	Post.where(:id => 10).limit(1).unscope(:where => :id, :limit).order('id DESC') = Post.order('id DESC')
	```

.EN	### `only`

.EN	You can also override conditions using the `only` method. For example:

	```ruby
	Post.where('id > 10').limit(20).order('id desc').only(:order, :where)
	```

.EN	The SQL that would be executed:

	```sql
	SELECT * FROM posts WHERE id > 10 ORDER BY id DESC
	```

.EN	### `reorder`

.EN	The `reorder` method overrides the default scope order. For example:

	```ruby
	class Post < ActiveRecord::Base
	  ..
	  ..
	  has_many :comments, order: 'posted_at DESC'
	end

	Post.find(10).comments.reorder('name')
	```

.EN	The SQL that would be executed:

	```sql
	SELECT * FROM posts WHERE id = 10 ORDER BY name
	```

.EN	In case the `reorder` clause is not used, the SQL executed would be:

```sql
SELECT * FROM posts WHERE id = 10 ORDER BY posted_at DESC
```

.EN	### `reverse_order`

.EN	The `reverse_order` method reverses the ordering clause if specified.

	```ruby
	Client.where("orders_count > 10").order(:name).reverse_order
	```

.EN	The SQL that would be executed:

	```sql
	SELECT * FROM clients WHERE orders_count > 10 ORDER BY name DESC
	```

.EN	If no ordering clause is specified in the query, the `reverse_order` orders by the primary key in reverse order.

	```ruby
	Client.where("orders_count > 10").reverse_order
	```

.EN	The SQL that would be executed:

	```sql
	SELECT * FROM clients WHERE orders_count > 10 ORDER BY clients.id DESC
	```

	This method accepts **no** arguments.

.EN	Null Relation
	-------------

.EN	The `none` method returns a chainable relation with no records. Any subsequent conditions chained to the returned relation will continue generating empty relations. This is useful in scenarios where you need a chainable response to a method or a scope that could return zero results.

	```ruby
	Post.none # returns an empty Relation and fires no queries.
	```

	```ruby
	# The visible_posts method below is expected to return a Relation.
	@posts = current_user.visible_posts.where(name: params[:name])

	def visible_posts
	  case role
	  when 'Country Manager'
	    Post.where(country: country)
	  when 'Reviewer'
	    Post.published
	  when 'Bad User'
	    Post.none # => returning [] or nil breaks the caller code in this case
	  end
	end
	```

.EN	Readonly Objects
.EN	----------------
.JA	読み取り専用オブジェクト
.JA	--------------------------

.EN	To explicitly disallow modification/destruction of the matching records returned in a Relation object, you could chain the `readonly` method as `true` to the find call.
.JA	リレーションによって返されたレコードが変更されたり破壊されるのを明示的に防ぐには、 `readonly` メソッドに `true` を指定しておいてから、find の呼び出しを繋げます。

.EN	Any attempt to alter or destroy the readonly records will not succeed, raising an `ActiveRecord::ReadOnlyRecord` exception. To set this option, specify it like this:
.JA	読取専用レコードに対して変更や削除を行うことはできず、例外 `ActiveRecord::ReadOnlyRecord` が発生します。このオプションを指定するには、次のようにしてください:

	```ruby
	Client.first.readonly(true)
	```

.EN	If you assign this record to a variable client, calling the following code will raise an `ActiveRecord::ReadOnlyRecord` exception:
.JA	もしこのレコードを変数 client に代入して、次のようなコードを実行すると、 `ActiveRecord::ReadOnlyRecord` 例外が発生します:

	```ruby
	client = Client.first.readonly(true)
	client.locked = false
	client.save
	```

.EN	Locking Records for Update
.EN	--------------------------
.JA	更新用にレコードをロックする
.JA	------------------------------

.EN	Locking is helpful for preventing the race conditions when updating records in the database and ensuring atomic updated. Active Record provides two locking mechanism:
.JA	ロックは、データベース中のレコードを更新するときに競合条件 (Race condition) を避けるのに役立ちます。また更新をアトミックに行うことも保証してくれます。 Active Record は 2 種類のロックメカニズムを提供しています:

.EN	* Optimistic Locking
.EN	* Pessimistic Locking
.JA	* 楽観的ロック
.JA	* 悲観的ロック

.EN	### Optimistic Locking
.JA	### 楽観的ロック

.EN	Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data.  It does this by checking whether another process has made changes to a record since it was opened. An `ActiveRecord::StaleObjectError` exception is thrown if that has occurred and the update is ignored.
.JA	楽観的ロックは、複数のユーザが同じレコードに更新のためにアクセスする場合において、データの衝突 (conflict) があまりないことを仮定した方法です。この方法では、対象レコードを取り出して以降、〔訳注: 更新する際に〕他のプロセスがそのレコードに対して変更を行ったかどうかをチェックします。もし〔訳注: 他プロセスによる変更が〕行われていた場合は `ActiveRecord::StaleObjectError` が発生し、更新は行われません。

.EN	**Optimistic locking column**
.JA	**楽観的ロック用のカラム**

.EN	In order to use optimistic locking, the table needs to have a column called `lock_version`. Each time the record is updated, Active Record increments the `lock_version` column and the locking facilities ensure that records instantiated twice will let the last one saved raise an `ActiveRecord::StaleObjectError` exception if the first was also updated. Example:
.JA	楽観的ロッックを使用する場合、 `lock_version` という名前のカラムがテーブルに必要です。レコードが更新されるたびに、Active Record は `lock_version` カラムの値を 1 増やします。こうすることでロック機構は、同じレコードが 2 度インスタンス化されてかつ最初のほうが更新された場合、2 つめのほうがセーブされたときに `ActiveRecord::StaleObjectError` 例外を必ず発生させます。

	```ruby
	c1 = Client.find(1)
	c2 = Client.find(1)

	c1.first_name = "Michael"
	c1.save

	c2.name = "should fail"
.EN	c2.save # Raises an ActiveRecord::StaleObjectError
.JA	c2.save # ActiveRecord::StaleObjectError 例外が発生する
	```

.EN	You're then responsible for dealing with the conflict by rescuing the exception and either rolling back, merging, or otherwise apply the business logic needed to resolve the conflict.
.JA	更新が衝突したときに、例外を rescue して、ロールバックしたり更新をマージしたりあるいは衝突を解消する何らかのビジネスロジックを実行するのは、開発者の仕事となります。

.EN	This behavior can be turned off by setting `ActiveRecord::Base.lock_optimistically = false`.
.JA	この挙動は `ActiveRecord::Base.lock_optimistically = false` によってオフにすることができます。

.EN	To override the name of the `lock_version` column, `ActiveRecord::Base` provides a class method called `set_locking_column`:
.JA	`lock_version` カラムの名前を変更するために、`ActiveRecord::Base` は `set_locking_column` というメソッドを用意しています:

	```ruby
	class Client < ActiveRecord::Base
	  self.locking_column = :lock_client_column
	end
	```

.EN	### Pessimistic Locking
.JA	### 悲観的ロック

.EN	Pessimistic locking uses locking mechanism provided by the underlying database. Passing `lock: true` to `Model.find` obtains an exclusive lock on the selected rows. `Model.find` using `:lock` are usually wrapped inside a transaction for preventing deadlock conditions.
.JA	悲観的ロックは、データベースが持っている機能を使ったロックメカニズムです。 `Model.find` を `lock: true` に渡すことで、選択された行に排他的ロックをかけることができます。 `:lock` つきの `Model.find` は通常、デッドロック条件を防ぐためにトランザクション内で使用されます。

.EN	For example:
.JA	たとえば:

	```ruby
	Item.transaction do
	  ji = Item.lock.first
	  i.name = 'Jones'
	  i.save
	end
	```

.EN	The above session produces the following SQL for a MySQL backend:
.JA	このセッションは次のような SQL を生成します (MySQL の場合):

	```sql
	SQL (0.2ms)   BEGIN
	Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
	Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
	SQL (0.8ms)   COMMIT
	```

.EN	You can also pass raw SQL to the `:lock` option to allow different types of locks. For example, MySQL has an expression called `LOCK IN SHARE MODE` where you can lock a record but still allow other queries to read it. To specify this expression just pass it in as the lock option:
.JA	また `:lock` オプションには生の SQL を渡すことで別の種類のロックを使うこともできます。たとえば MySQL には `LOCK IN SHARE MODE` という式があり、これはレコードにロックをかけるけど他のユーザがクエリで読み取ることは許すというものです。この式を指定するには、lock オプションにその式をそのまま渡します:

	```ruby
	Item.transaction do
      i = Item.lock("LOCK IN SHARE MODE").find(1)
	  i.increment!(:views)
	end
	```

.EN	Joining Tables
.EN	--------------
.JA	テーブルのジョイン
.JA	-------------------

.EN	`Model.find` provides a `:joins` option for specifying `JOIN` clauses on the resulting SQL. There multiple different ways to specify the `:joins` option:
.JA	`Model.find` は SQL における `JOIN` 句を指定するための `:joins` オプションを提供しています。`:joins` オプションの指定方法は複数あります:

.EN	### Using a String SQL Fragment
.JA	### 文字列による SQL フラグメントを使った方法

.EN	You can just supply the raw SQL specifying the `JOIN` clause to the `:joins` option. For example:
.JA	`:joins` オプションに、`JOIN` 句を表す生の SQL を指定できます。たとえば:

	```ruby
	Client.joins('LEFT OUTER JOIN addresses ON addresses.client_id = clients.id')
	```

.EN	This will result in the following SQL:
.JA	これは次のような SQL になります:

	```sql
	SELECT clients.* FROM clients LEFT OUTER JOIN addresses ON addresses.client_id = clients.id
	```

.EN	### Using Array/Hash of Named Associations
.JA	### 名前付きアソシエーションの配列またはハッシュを使う

.EN	WARNING: This method only works with `INNER JOIN`,
.JA	WARNING: この方法は `INNER JOIN` に対してのみ有効。

.EN	Active Record lets you use the names of the "associations":association_basics.html defined on the model as a shortcut for specifying the `:joins` option.
.JA	Active Record では `:joins` オプションを指定するときに、モデルクラスで定義された "アソシエーション":association_basics.html の名前を短縮名として指定できます。

.EN	For example, consider the following `Category`, `Post`, `Comments` and `Guest` models:
.JA	たとえば、 `Category` と `Post` と `Comments` と `Guest` というモデルがあったとします:

	```ruby
	class Category < ActiveRecord::Base
	  has_many :posts
	end

	class Post < ActiveRecord::Base
	  belongs_to :category
	  has_many :comments
	  has_many :tags
	end

	class Comment < ActiveRecord::Base
	  belongs_to :post
	  has_one :guest
	end

	class Guest < ActiveRecord::Base
	  belongs_to :comment
	end

	class Tag < ActiveRecord::Base
	  belongs_to :post
	end
	```

.EN	Now all of the following will produce the expected join queries using `INNER JOIN`:
.JA	この場合、以下に示す例のすべてで、 `INNER JOIN` を使った期待通りの join クエリが生成されます:

.EN	#### Joining a Single Association
.JA	#### 単一のアソシエーションによるジョイン

	```ruby
	Category.joins(:posts)
	```

.EN	This produces:
.JA	この結果は次の通りです:

	```sql
	SELECT categories.* FROM categories
	  INNER JOIN posts ON posts.category_id = categories.id
	```

.EN	#### Joining Multiple Associations
.JA	#### 複数のアソシエーションによるジョイン

	```ruby
	Post.joins(:category, :comments)
	```

.EN	This produces:
.JA	この結果は次の通りです:

	```sql
	SELECT posts.* FROM posts
	  INNER JOIN categories ON posts.category_id = categories.id
	  INNER JOIN comments ON comments.post_id = posts.id
	```

.EN	#### Joining Nested Associations (Single Level)
.JA	#### 入れ子 (1 段) になったアソシエーションによるジョイン

	```ruby
	Post.joins(comments: :guest)
	```

.EN	#### Joining Nested Associations (Multiple Level)
.JA	#### 入れ子 (多段) になったアソシエーションによるジョイン

	```ruby
	Category.joins(posts: [{comments: :guest}, :tags])
	```

.EN	### Specifying Conditions on the Joined Tables
.JA	### ジョイン用テーブルを使った条件の指定

.EN	You can specify conditions on the joined tables using the regular "Array":#array-conditions and "String":#pure-string-conditions conditions. "Hash conditions":#hash-conditions provides a special syntax for specifying conditions for the joined tables:
.JA	通常の "配列による条件指定":#array-conditions または "文字列による条件指定":#pure-string-conditions を、ジョイン用テーブル (joined table) に対して指定できます。 "ハッシュによる条件指定":#hash-conditions は、ジョイン用テーブルに対して特別な文法を提供します:

	```ruby
	time_range = (Time.now.midnight - 1.day)..Time.now.midnight
	Client.joins(:orders).where('orders.created_at' => time_range)
	```

.EN	An alternative and cleaner syntax to this is to nest the hash conditions:
.JA	より明確な別の方法として、ハッシュによる条件指定を入れ子にする方法があります:

	```ruby
	time_range = (Time.now.midnight - 1.day)..Time.now.midnight
	Client.joins(:orders).where(orders: {created_at: time_range})
	```

.EN	This will find all clients who have orders that were created yesterday, again using a `BETWEEN` SQL expression.
.JA	この例では SQL の `BETWEEN` 式を使って、昨日に注文を作成した顧客をすべて検索します。

.EN	Eager Loading Associations
.EN	--------------------------
.JA	Eager ローディングアソシエーション
.EN	------------------------------------

.EN	Eager loading is the mechanism for loading the associated records of the objects returned by `Model.find` using as few queries as possible.
.JA	Eager ローディングは、 `Model.find` によって返されるオブジェクトに関連した (associated) レコードを、できるだけ少ないクエリを使って読み込むメカニズムです。

.EN	**N + 1 queries problem**
.JA	**N + 1 クエリ問題**

.EN	Consider the following code, which finds 10 clients and prints their postcodes:
.JA	次のようなコードを考えます。これは、顧客を 10 名検索してそれらの郵便番号を表示しています:

.EN	```ruby
.EN	clients = Client.all(limit: 10)

.EN	clients.each do |client|
.EN	  puts client.address.postcode
.EN	end
.EN	```

.EN	This code looks fine at the first sight. But the problem lies within the total number of queries executed. The above code executes 1 ( to find 10 clients ) <plus> 10 ( one per each client to load the address ) = **11** queries in total.
.JA	このコードは、一見問題がなさそうに思えます。しかし実行されるクエリの総数が問題となります。上のコードでは、1 個 ( 顧客 10 名を検索するため ) <plus> 10 個 ( 顧客ごとに住所を読み込むため ) = **11 個**のクエリが実行されます。

.EN	**Solution to N + 1 queries problem**
.JA	**N + 1 クエリ問題を解決する方法**

.EN	Active Record lets you specify all the associations in advanced that are going to be loaded. This is possible by specifying the `includes` method of the `Model.find` call. With `includes`, Active Record ensures that all the specified associations are loaded using minimum possible number of queries.
.JA	Active Record では、読み込まれるであろうアソシエーションを事前にすべて指定できます。これは `Model.find` の呼び出しに `includes` メソッドを指定することで実現できます。Active Record では、すべての指定されたアソシエーションが、最小のクエリ数で読み込まれます。

.EN	Revisiting the above case, we could rewrite `Client.all` to use eager load addresses:
.JA	上で出た例を改訂して、eager ローディングを使って住所を読み込むよう `Client.all` を書き直してみましょう:

.EN	```ruby
.EN	clients = Client.includes(:address).limit(10)

.EN	clients.each do |client|
.EN	  puts client.address.postcode
.EN	end
.EN	```

.EN	The above code will execute just **2** queries, as opposed to **11** queries in the previous case:
.JA	前は **11 個**のクエリが実行されたのに対し、上のコードはちょうど **2 個**のクエリだけが実行されます。

	```sql
	SELECT * FROM clients LIMIT 10
	SELECT addresses.* FROM addresses
	  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
	```

.EN	### Eager Loading Multiple Associations
.JA	### 複数のアソシエーションに体する Eager ローディング

.EN	Active Record lets you eager load any possible number of associations with a single `Model.find` call by using an array, hash, or a nested hash of array/hash with the `includes` method.
.JA	Active Record では、配列やハッシュやそれらの入れ子を `includes` メソッドに指定することで、ひとつの `Model.find` 呼び出しに対して任意の数のアソシエーションを Eager ローディングで読み込めます。

.EN	#### Array of Multiple Associations
.JA	#### 複数のアソシエーションを含む配列

	```ruby
	Post.includes(:category, :comments)
	```

.EN	This loads all the posts and the associated category and comments for each post.
.JA	この例はすべての投稿 (post) と、各投稿に関連したカテゴリやコメントを読み込みます。
.JA	〔訳注: どこに配列が?〕

.EN	#### Nested Associations Hash
.JA	#### ネストしたアソシエーションのハッシュ

	```ruby
	Category.includes(posts: [{comments: :guest}, :tags]).find(1)
	```

.EN	The above code finds the category with id 1 and eager loads all the posts associated with the found category. Additionally, it will also eager load every posts' tags and comments. Every comment's guest association will get eager loaded as well.
.JA	上のコードは、id が 1 であるカテゴリを検索し、そのカテゴリに関連したすべての投稿 (post) を Eager ローディングを使って読み込みます。また読み込まれた投稿に関連するタグとコメントも Eager ローディングを使って読み込みます。同様にすべてのコメントにおいても、ゲストのアソシエーションが Eager ローディングで読み込まれます。

.EN	### Specifying Conditions on Eager Loaded Associations
.JA	### Eager ローディングで読み込まれたアソシエーションに対する条件指定

.EN	Even though Active Record lets you specify conditions on the eager loaded associations just like `joins`, the recommended way is to use "joins":#joining-tables instead. 
.JA	Active Record は Eager ローディングで読み込まれたアソシエーションに対しても、ちょうど `joins` のときのように条件指定を行うことができますが、素直に "joins":#joining-tables メソッドを使うほうをお勧めします。

.EN	Dynamic Finders
.EN	---------------
.JA	動的ファインダ
.JA	---------------

.EN	For every field (also known as an attribute) you define in your table, Active Record provides a finder method. If you have a field called `name` on your `Client` model for example, you get `find_by_name` and `find_all_by_name` for free from Active Record. If you have also have a `locked` field on the `Client` model, you also get `find_by_locked` and `find_all_by_locked`.
.JA	Active Record では、テーブルに定義したどのフィールド (属性ともいう) にも使えるようなファインダ (finder) メソッド〔訳注: 検索用メソッドのこと〕が用意されています。たとえば `Client` モデルに `name` というフィールドがあるとすると、Active Record では `find_by_name` と `find_all_by_name` というメソッドが自動的に利用可能になります。もし `locked` というフィールドが `Client` モデルにあれば、 `find_by_locked` と `find_all_by_locked` が利用可能です。〔訳注: これらは事前に定義されるものではなく、呼ばれたときに初めて定義される検索用メソッドであり、これらを動的ファインダ (dynamic finder) といいます。〕

.EN	You can do `find_last_by_*` methods too which will find the last record matching your argument.
.JA	また引数にマッチした中で最後のレコードを取ってくるための `find_last_by_*` メソッドも利用できます。

.EN	You can specify an exclamation point (`!`) on the end of the dynamic finders to get them to raise an `ActiveRecord::RecordNotFound` error if they do not return any records, like `Client.find_by_name!("Ryan")`
.JA	たとえば `Client.find_by_name!("Ryan")` のように、エクスクラメーションポイント (「`!`」のこと) を動的ファインダ名の最後につけると、該当するレコードが見つからなかった場合は `ActiveRecord::RecordNotFound` エラーが発生します。

.EN	If you want to find both by name and locked, you can chain these finders together by simply typing `and` between the fields for example `Client.find_by_name_and_locked("Ryan", true)`.
.JA	name と locked の両方のフィールドを使って検索したい場合は、たとえば `Client.find_by_name_and_locked("Ryan", true)` のように、単にそれらを `and` でつなげるだけでいいです。


.EN	There's another set of dynamic finders that let you find or create/initialize objects if they aren't found. These work in a similar fashion to the other finders and can be used like `find_or_create_by_name(params[:name])`. Using this will firstly perform a find and then create if the find returns `nil`. The SQL looks like this for `Client.find_or_create_by_name("Ryan")`:
.JA	動的ファインダの別の種類として、オブジェクトを検索し、見つからなければ新規作成/初期化を行うというものもあります。これらは、メソッド名が `find_or_create_by_name(params[:name])` のようになる以外は、他のファインダと同じように動作します。

	```sql
	SELECT * FROM clients WHERE (clients.first_name = 'Andy') LIMIT 1
	BEGIN
    NSERT INTO clients (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
	COMMIT
	```

.EN	`find_or_create`'s sibling, `find_or_initialize`, will find an object and if it does not exist will act similar to calling `new` with the arguments you passed in. For example:
.JA	`find_or_create`'s の兄弟版として `find_or_initialize` があります。これは、まず検索を行い、見つからなかった場合は渡された引数を使って〔訳注: `create` ではなく〕 `new` を呼び出します。

	```ruby
	client = Client.find_or_initialize_by_name('Ryan')
	```

.EN	will either assign an existing client object with the name "Ryan" to the client local variable, or initialize a new object similar to calling `Client.new(name: 'Ryan')`. From here, you can modify other fields in client by calling the attribute setters on it: `client.locked = true` and when you want to write it to the database just call `save` on it.
.JA	上の場合だと、名前が "Ryan" である既存の顧客オブジェクトをローカル変数 client に代入するか、〔訳注: そのような顧客が見つからなければ〕 `Client.new(name: 'Ryan')` を呼び出して新しいオブジェクトを作成し初期化します。ここから、 `client.locked = true` のようにセッターメソッドを使って顧客の他のフィールドを変更できます。またそれをデータベースに保存したいときは `save` メソッドを呼び出します。

.EN	Finding by SQL
.EN	--------------
.JA	SQL による検索
.JA	--------------

.EN	If you'd like to use your own SQL to find records in a table you can use `find_by_sql`. The `find_by_sql` method will return an array of objects even if the underlying query returns just a single record. For example you could run this query:
.JA	`find_by_sql` を使って、テーブル中のレコードを検索するための独自の SQL を指定できます。 `find_by_sql` メソッドは、たとえ 1 つのレコードしか返さないような SQL が指定されたとしても、オブジェクトの配列を返します。たとえば次のようなクエリが実行できます:

	```ruby
	Client.find_by_sql("SELECT * FROM clients
	  INNER JOIN orders ON clients.id = orders.client_id
	  ORDER clients.created_at desc")
	```

.EN	`find_by_sql` provides you with a simple way of making custom calls to the database and retrieving instantiated objects.
.JA	`find_by_sql` を使えば、データベースのカスタムコールを呼び出してインスタンス化されたオブジェクトを取り出すのが、簡潔に実行できます。

.EN	### `select_all`
.JA	### `select_all`

.EN	`find_by_sql` has a close relative called `connection#select_all`. `select_all` will retrieve objects from the database using custom SQL just like `find_by_sql` but will not instantiate them. Instead, you will get an array of hashes where each hash indicates a record.
.JA	`find_by_sql` とよく似たものに `connection#select_all` というのがあります。 `select_all` は `find_by_sql` と同様にカスタム SQL を使ってデータベースからオブジェクトを取り出しますが、インスタンス化を行いません。かわりに、レコードごとのハッシュを要素とする配列が返されます。

	```ruby
	Client.connection.select_all("SELECT * FROM clients WHERE id = '1'")
	```

.EN	Existence of Objects
.EN	--------------------
.JA	オブジェクトの存在確認
.JA	-----------------------

.EN	If you simply want to check for the existence of the object there's a method called `exists?`. This method will query the database using the same query as `find`, but instead of returning an object or collection of objects it will return either `true` or `false`.
.JA	オブジェクトが存在するかどうかをチェックしたいだけなら、 `exists?` というメソッドが使えます。このメソッドは `find` と同じクエリを使ってデータベースを検索しますが、オブジェクトやそのコレクションを返すかわりに、 `true` または `false` を返します。

	```ruby
	Client.exists?(1)
	```

.EN	The `exists?` method also takes multiple ids, but the catch is that it will return true if any one of those records exists.
.JA	`exists?` メソッドは複数の id をとることができますが、そのうちのどれかひとつでも存在していれば true を返します。

	```ruby
	Client.exists?(1,2,3)
	# or
	Client.exists?([1,2,3])
	```

.EN	Further more, `exists` takes a `conditions` option much like find:
.JA	もっと言うと、 `exists` は find によく似た `conditions` オプションを取ることができます:

	```ruby
    Client.where(first_name: 'Ryan').exists?
	```

.EN	It's even possible to use `exists?` without any arguments:
.JA	引数なしで `exists?` を呼び出すことも可能です。

	```ruby
	Client.exists?
	```

.EN	The above returns `false` if the `clients` table is empty and `true` otherwise.
.JA	この場合、 `clients` テーブルが空なら `false` が返され、そうでなければ `true` が返されます。

.EN	Calculations
.EN	------------
.JA	計算
.EN	----

.EN	This section uses count as an example method in this preamble, but the options described apply to all sub-sections.
.JA	このセクションの前書きでは例として count メソッドを使用しますが、説明されたオプションはすべてのサブセクションで利用可能です。

.EN	`count` takes conditions much in the same way `exists?` does:
.JA	`count` では `exists?` と同じ方法で検索条件を指定できます:

	```ruby
	Client.count
	# SELECT count(*) AS count_all FROM clients
	```

.EN	Which will execute:
.JA	これは次のような SQL を実行します:

	```ruby
	Client.where(first_name: 'Ryan').count
	# SELECT count(*) AS count_all FROM clients WHERE (first_name = 'Ryan')
	```

.EN	You can also use the `includes` or `joins` methods for this to do something a little more complex:
.JA	より複雑なことをするのに `includes` メソッドや `joins` メソッドを使うことができます:

	```ruby
	Client.includes("orders").where(first_name: 'Ryan', orders: {status: 'received'}).count
	```

.EN	Which will execute:
.JA	これは次のような SQL を実行します:

	```sql
	SELECT count(DISTINCT clients.id) AS count_all FROM clients
	  LEFT OUTER JOIN orders ON orders.client_id = client.id WHERE
	  (clients.first_name = 'Ryan' AND orders.status = 'received')
	```

.EN	This code specifies `clients.first_name` just in case one of the join tables has a field also called `first_name` and it uses `orders.status` because that's the name of our join table.
.JA	このコードでは、ジョイン用のテーブル〔訳注: である orders 〕も `first_name` というカラム名を持っている場合を考慮し、 `clients.first_name` を指定しています。またジョイン用のテーブルが `orders` なので、 `orders.status` を指定しています。〔訳注: 要レビュー〕

.EN	### Count
.JA	### カウント

.EN	If you want to see how many records are in your model's table you could call `Client.count` and that will return the number. If you want to be more specific and find all the clients with their age present in the database you can use `Client.count(:age)`.
.JA	モデルのテーブル中にどれだけのレコードがあるか調べたい場合、 `Client.count` を呼ぶとレコード数を返します。もっと詳しく調べたい、たとえばデータベース中のすべてのクライアントを現在の年齢とともに調べたい場合は、 `Client.count(:age)` のようにします。〔訳注: 要レビュー〕

.EN	For options, please see the parent section, "Calculations":#calculations.
.JA	オプションについては、前の "Calculations":#calculations セクションをご覧下さい。

.EN	### Average
.JA	### 平均値

.EN	If you want to see the average of a certain number in one of your tables you can call the `average` method on the class that relates to the table. This method call will look something like this:
.JA	もしテーブル中のある数値の平均値を知りたい場合は、そのテーブルと対応するクラスの `average` メソッドを呼び出します。このメソッド呼び出しは次のような感じになるでしょう:

	```ruby
	Client.average("orders_count")
	```

.EN	This will return a number (possibly a floating point number such as 3.14159265) representing the average value in the field.
.JA	この例だと、フィールドの平均値を表す数 (典型的には 3.14159265 のような浮動小数点数) を返します。

.EN	For options, please see the parent section, "Calculations":#calculations.
.JA	利用可能なオプションについては前の "計算":#calculations のセクションをご覧下さい。

.EN	### Minimum
.JA	### 最小値

.EN	If you want to find the minimum value of a field in your table you can call the `minimum` method on the class that relates to the table. This method call will look something like this:
.JA	もしテーブル中のあるフィールドの最小値を調べたいなら、そのテーブルと対応するクラスの `minimum` メソッドを呼び出します。このメソッド呼び出しは次のような感じになります:

	```ruby
	Client.minimum("age")
	```

.EN	For options, please see the parent section, "Calculations":#calculations.
.JA	利用可能なオプションについては前の "計算":#calculations のセクションをご覧下さい。

.EN	### Maximum
.JA	### 最大値

.EN	If you want to find the maximum value of a field in your table you can call the `maximum` method on the class that relates to the table. This method call will look something like this:
.JA	もしテーブル中のあるフィールドの最大値を調べたいなら、そのテーブルと対応するクラスの `maximum` メソッドを呼び出します。このメソッド呼び出しは次のような感じになります:

	```ruby
	Client.maximum("age")
	```

.EN	For options, please see the parent section, "Calculations":#calculations.
.JA	利用可能なオプションについては前の "計算":#calculations のセクションをご覧下さい。

.EN	### Sum
.JA	### 合計値

.EN	If you want to find the sum of a field for all records in your table you can call the `sum` method on the class that relates to the table. This method call will look something like this:
.JA	もしテーブル中のあるフィールドの合計値を調べたいなら、そのテーブルと対応するクラスの `sum` メソッドを呼び出します。このメソッド呼び出しは次のような感じになります:

	```ruby
	Client.sum("orders_count")
	```

.EN	For options, please see the parent section,  "Calculations":#calculations.
.JA	利用可能なオプションについては前の "計算":#calculations のセクションをご覧下さい。

.EN	h3. Changelog
.JA	h3. 更新履歴

	"Lighthouse ticket":http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/16

	* April 7, 2010: Fixed document to validate XHTML 1.0 Strict. "Jaime Iniesta":http://jaimeiniesta.com
	* February 3, 2010: Update to Rails 3 by "James Miller":credits.html#bensie
	* February 7, 2009: Second version by "Pratik":credits.html#lifo
	* December 29 2008: Initial version by "Ryan Bigg":credits.html#radar
