.EN	h2. Active Record Query Interface
.JA	h2. Active Record クエリインタフェース

.EN	This guide covers different ways to retrieve data from the database using Active Record. By referring to this guide, you will be able to:
.JA	本ガイドでは、Active Record を使ってデータベースからデータをとってくるさまざまな方法を説明します。本ガイドを参照することで、以下のことができるようになるでしょう:

.EN	* Find records using a variety of methods and conditions
.EN	* Specify the order, retrieved attributes, grouping, and other properties of the found records
.EN	* Use eager loading to reduce the number of database queries needed for data retrieval
.EN	* Use dynamic finders methods
.EN	* Check for the existence of particular records
.EN	* Perform various calculations on Active Record models
.JA	* いろんなメソッドや条件を使ってレコードを検索する
.JA	* 検索できたレコードの順番や、抽出するカラムや、グルーピングなどのプロパティを指定する
.JA	* Eager loading を使うことで、データの抽出に必要なデータベースクエリの数を減らす
.JA	* 動的finderメソッドを使う
.JA	* 特定のレコードについて存在するかどうかを調べる
.JA	* Active Record モデルで様々な計算を実行する

.EN	endprologue.
.JA	endprologue.

.EN	WARNING. This Guide is based on Rails 3.0. Some of the code shown here will not work in other versions of Rails.
.JA	警告: 本ガイドでは Rails 3.0 を使っています。ここで登場するコードは、他のバージョンのRailsでは動作しないでしょう。

.EN	If you're used to using raw SQL to find database records then, generally, you will find that there are better ways to carry out the same operations in Rails. Active Record insulates you from the need to use SQL in most cases.
.JA	もし生のSQLを使ってデータベースレコードを検索しているなら、一般的に言って、Rails では同じことをもっとうまい方法でできることがわかるでしょう。Active Record を使えばほとんどの場合においてSQLを使う必要はありません。

.EN	Code examples throughout this guide will refer to one or more of the following models:
.JA	本ガイドに登場するコード例では、次のようなモデルを使います:

.EN	TIP: All of the following models use +id+ as the primary key, unless specified otherwise.
.JA	TIP: 以下に示すモデルはすべて、特に指定がない限りは主キーとして +id+ を使います。

	<br />
	
	<ruby>
	class Client < ActiveRecord::Base
	  has_one :address
	  has_many :orders
	  has_and_belongs_to_many :roles
	end
	</ruby>
	
	<ruby>
	class Address < ActiveRecord::Base
	  belongs_to :client
	end
	</ruby>
	
	<ruby>
	class Order < ActiveRecord::Base
	  belongs_to :client, :counter_cache => true
	end
	</ruby>
	
	<ruby>
	class Role < ActiveRecord::Base
	  has_and_belongs_to_many :clients
	end
	</ruby>

.EN	Active Record will perform queries on the database for you and is compatible with most database systems (MySQL, PostgreSQL and SQLite to name a few). Regardless of which database system you're using, the Active Record method format will always be the same.
.JA	Active Record はデータベースに対してクエリを実行します。また Active Record はほとんどのデータベースシステム (いくつか例を挙げますと MySQL や PostgreSQL や SQLite) で互換性があります。どのデータベースシステムを使おうとも、Active Record のメソッド形式はつねに同じです。

.EN	h3. Retrieving Objects from the Database
.JA	h3. デーベースから 1 件取り出す

.EN	To retrieve objects from the database, Active Record provides several finder methods. These methods allows you to pass arguments into it to perform certain queries on your database without the need of writing raw SQL.
.JA	データベースからオブジェクトを取り出すために、Active Record は検索用メソッドをいくつか用意しています。これらのメソッドに引数を渡すことで、生のSQLを書くことなしに、データベースに対して特定のクエリを実行することができます。

.EN	The methods are:
.JA	そのためのメソッドがこちらです:
	* +where+
	* +select+
	* +group+
	* +order+
	* +limit+
	* +offset+
	* +joins+
	* +includes+
	* +lock+
	* +readonly+
	* +from+

.EN	All of these methods return a Relation
.JA	これらメソッドはどれも Relation 〔訳注: クラスのオブジェクト〕を返します。

.EN	Primary operation of <tt>Model.find(options)</tt> can be summarized as:
.JA	<tt>Model.find(options)</tt> の主な操作をまとめると:

.EN	* Convert the supplied options to an equivalent SQL query.
.EN	* Fire the SQL query and retrieve the corresponding results from the database.
.EN	* Instantiate the equivalent Ruby object of the appropriate model for every resulting row.
.EN	* Run +after_find+ callbacks if any.
.JA	* 与えられたオプションを同等の SQL クエリに変換すること。
.JA	* SQL クエリを実行し、対応する結果をデータベースから抽出すること。
.JA	* 各行に応じたモデルの Ruby オブジェクトを作成すること。
.JA	* もしあれば after_find コールバックを呼び出すこと。

.EN	h4. Retrieving a Single Object
.JA	h4. オブジェクトをひとつ取り出す

.EN	Active Record lets you retrieve a single object using three different ways.
.JA	Active Record は、オブジェクトをひとつ取り出すための異なるメソッドを 3 つ用意しています。

.EN	h5. Using a Primary Key
.JA	h5. 主キーを使う

.EN	Using <tt>Model.find(primary_key)</tt>, you can retrieve the object corresponding to the supplied _primary key_ and matching the supplied options (if any). For example:
.JA	<tt>Model.find(primary_key</tt>) を使うことで、 _primary key_ に対応したオブジェクトや (もしあれば) オプションに一致したオブジェクトを取り出せます。たとえば:

	<ruby>
.EN	# Find the client with primary key (id) 10.
.JA	# 主キー (id) が 10 である顧客を検索する
	client = Client.find(10)
	=> #<Client id: 10, name: => "Ryan">
	</ruby>

.EN	SQL equivalent of the above is:
.JA	これと同等の SQl は次の通りです:

	<sql>
	SELECT * FROM clients WHERE (clients.id = 10)
	</sql>

.EN	<tt>Model.find(primary_key)</tt> will raise an +ActiveRecord::RecordNotFound+ exception if no matching record is found.
.JA	<tt>Model.find(primary_key)</tt> は、もし該当するレコードが見つからなければ、+ActiveRecord::RecordNotFound+ 例外を発生させます。

.EN	h5. +first+
.JA	h5. +first+

.EN	<tt>Model.first</tt> finds the first record matched by the supplied options. For example:
.JA	<tt>Model.first</tt> は指定されたオプションに一致するレコードのうち最初のものを返します。たとえば:

	<ruby>
	client = Client.first
	=> #<Client id: 1, name: => "Lifo">
	</ruby>

.EN	SQL equivalent of the above is:
.JA	これに対応する SQL は:

	<sql>
	SELECT * FROM clients LIMIT 1
	</sql>

.EN	<tt>Model.first</tt> returns +nil+ if no matching record is found. No exception will be raised.
.JA	<tt>Model.first</tt> は、もし一致するレコードがなければ nil を返します。例外は発生しません。

.EN	h5. +last+
.JA	h5. +last+

.EN	<tt>Model.last</tt> finds the last record matched by the supplied options. For example:
.JA	<tt>Model.last</tt> は指定されたオプションに一致するレコードのうち最後のものを返します。たとえば:

	<ruby>
	client = Client.last
	=> #<Client id: 221, name: => "Russel">
	</ruby>

.EN	SQL equivalent of the above is:
.JA	これに対応する SQL は:

	<sql>
	SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
	</sql>

.EN	<tt>Model.last</tt> returns +nil+ if no matching record is found. No exception will be raised.
.JA	<tt>Model.last</tt> は、もし一致するレコードがなければ +ni+l を返します。例外は発生しません。

.EN	h4. Retrieving Multiple Objects
.JA	h4. 複数のオブジェクトを取り出す

.EN	h5. Using Multiple Primary Keys
.JA	h5. 複数の主キーを使う

.EN	<tt>Model.find(array_of_primary_key)</tt> also accepts an array of _primary keys_. An array of all the matching records for the supplied _primary keys_ is returned. For example:
.JA	<tt>Model.find(array_of_primary_key)</tt> は、引数として _primary keys_ の配列を取ることもできます。この場合、指定された _primary keys_ にマッチしたレコードが返されます。たとえば:

	<ruby>
.EN	# Find the clients with primary keys 1 and 10.
.JA	# 主キーが 1 と 10 の顧客を検索する
	client = Client.find(1, 10) # Or even Client.find([1, 10])
	=> [#<Client id: 1, name: => "Lifo">, #<Client id: 10, name: => "Ryan">]
	</ruby>

.EN	SQL equivalent of the above is:
.JA	これと同等の SQL は:

	<sql>
	SELECT * FROM clients WHERE (clients.id IN (1,10))
	</sql>

.EN	<tt>Model.find(array_of_primary_key)</tt> will raise an +ActiveRecord::RecordNotFound+ exception unless a matching record is found for <strong>all</strong> of the supplied primary keys.
.JA	<tt>Model.find(array_of_primary_key)</tt> は、指定された主キーにマッチするレコードが<strong>ひとつでも</strong>見つからない場合は、+ActiveRecord::RecordNotFound+ 例外を発生させます〔訳注: すべて見つかった場合のみ例外は発生しない〕。

.EN	h4. Retrieving Multiple Objects in Batches
.JA	h4. 複数のオブジェクトをバッチ方式で取り出す

.EN	Sometimes you need to iterate over a large set of records. For example to send a newsletter to all users, to export some data, etc. 
.JA	時には、非常にたくさんのレコードに対して繰り返しを行わなければならないことがあります。たとえば、全ユーザに対してニュースレターを送信する場合や、何らかのデータをエクスポート (export) する場合などです。

.EN	The following may seem very straight forward at first:
.JA	まず最初に、ごく単純な方法を示します:

	<ruby>
.EN	# Very inefficient when users table has thousands of rows.
.JA	# users テーブルが数千行ある場合はとても効率が悪い
	User.each do |user|
	  NewsLetter.weekly_deliver(user)
	end
	</ruby>

.EN	But if the total number of rows in the table is very large, the above approach may vary from being under performant to just plain impossible.
.JA	しかしテーブル内の行数が非常に多いと、このアプローチではパフォーマンスが悪かったり、最悪だと実行すらできないことがあります。

.EN	This is because +User.each+ makes Active Record fetch _the entire table_, build a model object per row, and keep the entire array in the memory. Sometimes that is just too many objects and demands too much memory.
.JA	これは、+User.each+ が _テーブル全体_ に対して Active Record によるフェッチを行い、行ごとのモデルオブジェクトを作成し、それらをすべてメモリ上の配列に格納してしまうことが原因です。時にはこの方法はあまりに多くのオブジェクトを作成してしまうため、一度にあまりに多くのメモリを消費することになります。

.EN	h5. +find_each+
.JA	h5. +find_each+

.EN	To efficiently iterate over a large table, Active Record provides a batch finder method called +find_each+:
.JA	巨大なテーブル全体に対して効率的に繰り返しを行うために、Active Record はバッチ形式の検索用メソッドである +find_each+ を提供しています:

	<ruby>
	User.find_each do |user|
	  NewsLetter.weekly_deliver(user)
	end
	</ruby>

.EN	*Configuring the batch size*
.JA	*バッチサイズを設定する*

.EN	Behind the scenes +find_each+ fetches rows in batches of +1000+ and yields them one by one. The size of the underlying batches is configurable via the +:batch_size+ option.
.JA	+find_each+ の裏側では、1 回のバッチで +1000+ 行がフェッチされてから 1 行ずつ yield が実行されます。この、裏側で行われているバッチのサイズを変更するには、+:batch_size+ オプションを指定します。

.EN	To fetch +User+ records in batch size of +5000+:
.JA	バッチサイズ +5000+ で +User+ のレコードを取ってくるには:

	<ruby>
	User.find_each(:batch_size => 5000) do |user|
	  NewsLetter.weekly_deliver(user)
	end
	</ruby>

.EN	*Starting batch find from a specific primary key*
.JA	*バッチによる検索を開始するときの主キーを指定する*

.EN	Records are fetched in ascending order on the primary key, which must be an integer. The +:start+ option allows you to configure the first ID of the sequence if the lowest is not the one you need. This may be useful for example to be able to resume an interrupted batch process if it saves the last processed ID as a checkpoint.
.JA	レコードは主キーの昇順でフェッチされます。主キーは整数でなければなりません。番号の小さいものは必要としない場合、 +:start+ オプションを使えば、取り出すべき一連のレコードにおける最初の ID を設定できます。これは、たとえばバッチ処理が中断された場合に、最後に処理したレコードの ID をチェックポイントとして保存しておき、あとでその ID から処理を再開するような場合に役に立ちます。

.EN	To send newsletters only to users with the primary key starting from +2000+:
.JA	主キーが +2000+ 以降のユーザにだけニュースレターを送信する場合は:

	<ruby>
	User.find_each(:batch_size => 5000, :start => 2000) do |user|
	  NewsLetter.weekly_deliver(user)
	end
	</ruby>

.EN	*Additional options*
.JA	*追加できるオプション*

.EN	+find_each+ accepts the same options as the regular +find+ method. However, +:order+ and +:limit+ are needed internally and hence not allowed to be passed explicitly.
.JA	+find_each+ は通常の +find+ メソッドと同じオプションが利用できます。ただし +:order+ と +:limit+ は内部的に使用されるため、これらを +find_each+ で明示的に指定することはできません。

.EN	h5. +find_in_batches+
.JA	h5. +find_in_batches+

.EN	You can also work by chunks instead of row by row using +find_in_batches+. This method is analogous to +find_each+, but it yields arrays of models instead:
.JA	1 行ずつ処理を行うかわりに、+find_in_batches+ を使うことでチャンク〔訳注: データの固まり、ここでは配列を意味する〕ごとに処理を行うこともできます。このメソッドは +find_each+ に似てますが、〔訳注: モデルのかわりに〕モデルの配列を受け取って yield します:

	<ruby>
.EN	# Works in chunks of 1000 invoices at a time.
.JA	# 1 回につき 1000 件のインボイスを含むチャンクを処理する
	Invoice.find_in_batches(:include => :invoice_lines) do |invoices|
	  export.add_invoices(invoices)
	end
	</ruby>

.EN	The above will yield the supplied block with +1000+ invoices every time.
.JA	上のコードは毎回 1000 個のインボイスを使って、指定されたブロックを yield します。

.EN	h3. Conditions
.JA	h3. 検索条件

.EN	The +find+ method allows you to specify conditions to limit the records returned, representing the +WHERE+-part of the SQL statement. Conditions can either be specified as a string, array, or hash.
.JA	find メソッドでは、返されるレコードを限定するための検索条件を指定できます。これは SQL 文でいうところの WHERE 句で表されます。条件は文字列や配列やハッシュで指定できます。

.EN	h4. Pure String Conditions
.JA	h4. 文字列だけを使った検索条件

.EN	If you'd like to add conditions to your find, you could just specify them in there, just like +Client.where("orders_count = '2'")+. This will find all clients where the +orders_count+ field's value is 2.
.JA	もし find に検索条件を追加するなら、それをたとえば +Client.where("orders_count = '2'")+ のようにその場で指定でき、この場合なら +orders_count+ フィールドの値が 2 であるようなクライアントをすべて検索します。

.EN	WARNING: Building your own conditions as pure strings can leave you vulnerable to SQL injection exploits. For example, +Client.where("name LIKE '%#{params[:name]}%'")+ is not safe. See the next section for the preferred way to handle conditions using an array.
.JA	警告: 条件を文字列だけで組み立てるのは、SQL インジェクションの脆弱性を残してしまう危険性が高いです。たとえば +Client.where("name LIKE '%#{params[:name]}%'")+ は安全ではありません。次のセクションで、配列を使って検索条件を構築するという、より好ましい方法を説明します。

.EN	h4. Array Conditions
.JA	h4. 配列を使った検索条件

.EN	Now what if that number could vary, say as an argument from somewhere, or perhaps from the user's level status somewhere? The find then becomes something like:
.JA	たとえば何かの引数をもとにしたり、ユーザレベルのステータスとかなにかをもとにするといった、数値が変化するような場合はどうするのでしょう?

.EN	<ruby>
.EN	Client.where(["orders_count = ?", params[:orders]])
.EN	</ruby>

.EN	Active Record will go through the first element in the conditions value and any additional elements will replace the question marks +(?)+ in the first element.
.JA	Active Record は条件値の最初の要素を取り出し、その中のクエスチョンマーク +(?)+ を残りの要素で置き換えます。

.EN	Or if you want to specify two conditions, you can do it like:
.JA	あるいは、もし 2 つの条件を指定したい場合は次のようにします:

	<ruby>
	Client.where(["orders_count = ? AND locked = ?", params[:orders], false])
	</ruby>

.EN	In this example, the first question mark will be replaced with the value in +params[:orders]+ and the second will be replaced with the SQL representation of +false+, which depends on the adapter.
.JA	この例では、1 つ目のクエスチョンマークは +params[:orders]+ の値で置き換わり、2 つ目は +false+ の SQL 的表現 (これはアダプタごとに異なります) で置き換わります。

.EN	The reason for doing code like:
.JA	〔訳注: 「?」を使った〕次のような書き方は:

.EN	<ruby>
.EN	Client.where(["orders_count = ?", params[:orders]])
.EN	</ruby>

.EN	instead of:
.JA	〔訳注: 「#{}」を使った〕次のような書き方よりも:

.EN	<ruby>
.EN	Client.where("orders_count = #{params[:orders]}")
.EN	</ruby>

.EN	is because of argument safety. Putting the variable directly into the conditions string will pass the variable to the database *as-is*. This means that it will be an unescaped variable directly from a user who may have malicious intent. If you do this, you put your entire database at risk because once a user finds out he or she can exploit your database they can do just about anything to it. Never ever put your arguments directly inside the conditions string.
.JA	安全性の点において望ましいといえます。条件式の文字列に値を直接埋め込むと、値をデータベースに *そのままの形で* 渡してしまいます。これはつまり、その値というのが、悪意を持ったユーザによるエスケープされてない値である可能性があるということです。もしそうなった場合、悪意を持ったユーザがその弱点を見つけてしまえば、それを突いてデータベースに対して何でもできてしまうため、データベース全体が危険に晒されてしまいます。条件式の文字列に引数を直接埋め込むようなことは決してしてはいけません。

.EN	TIP: For more information on the dangers of SQL injection, see the "Ruby on Rails Security Guide":security.html#sql-injection.
.JA	TIP: SQL インジェクションの危険性についてのより詳しい情報は、"Ruby on Rails Security Guide":security.html#sql-injection を参照してください。

.EN	h5. Placeholder Conditions
.JA	h5. プレースホルダを使った検索条件

.EN	Similar to the +(?)+ replacement style of params, you can also specify keys/values hash in your array conditions:
.JA	「 +?+ 」を使った置換と似たような方法として、配列の条件式にハッシュのキーと値で指定することもできます:

	<ruby>
	Client.where(
	  ["created_at >= :start_date AND created_at <= :end_date", { :start_date => params[:start_date], :end_date => params[:end_date] }])
	</ruby>

.EN	This makes for clearer readability if you have a large number of variable conditions.
.JA	この方法は、条件式の可変部が多い場合は可読性がより高くなります。

.EN	h5(#array-range_conditions). Range Conditions
.JA	h5(#array-range_conditions). 範囲を指定した検索条件

.EN	If you're looking for a range inside of a table (for example, users created in a certain timeframe) you can use the conditions option coupled with the +IN+ SQL statement for this. If you had two dates coming in from a controller you could do something like this to look for a range:
.JA	もしテーブル内の範囲 (たとえばある期間内に作成されたユーザなど) を検索しようとしているなら、SQL 文における IN に相当する条件オプションが利用可能です。もし 2 つの日付がコントローラからもたらされるなら、範囲を使った検索は次のようになります:

	<ruby>
	Client.where(["created_at IN (?)",
	  (params[:start_date].to_date)..(params[:end_date].to_date)])
	</ruby>

.EN	This would generate the proper query which is great for small ranges but not so good for larger ranges. For example if you pass in a range of date objects spanning a year that's 365 (or possibly 366, depending on the year) strings it will attempt to match your field against.
.JA	こうすると、Range オブジェクトの下限以上かつ上限以下であるような、適切なクエリが生成されます。たとえば 1 年間 365 日 (または年によっては 366 日) を表すような date オブジェクトの Range オブジェクトを渡すと、次のような SQL が生成されます。

	<sql>
	SELECT * FROM users WHERE (created_at IN
	  ('2007-12-31','2008-01-01','2008-01-02','2008-01-03','2008-01-04','2008-01-05',
	  '2008-01-06','2008-01-07','2008-01-08','2008-01-09','2008-01-10','2008-01-11',
	  '2008-01-12','2008-01-13','2008-01-14','2008-01-15','2008-01-16','2008-01-17',
	  '2008-01-18','2008-01-19','2008-01-20','2008-01-21','2008-01-22','2008-01-23',...
	  ‘2008-12-15','2008-12-16','2008-12-17','2008-12-18','2008-12-19','2008-12-20',
	  '2008-12-21','2008-12-22','2008-12-23','2008-12-24','2008-12-25','2008-12-26',
	  '2008-12-27','2008-12-28','2008-12-29','2008-12-30','2008-12-31'))
	</sql>

.EN	h5. Time and Date Conditions
.JA	h5. 時刻 (Time) と日付 (Date) の検索条件

.EN	Things can get *really* messy if you pass in Time objects as it will attempt to compare your field to *every second* in that range:
.JA	もし Time オブジェクトを渡したら、 *本当に* 大変なことになります。なぜなら、比較対象となるフィールドと、範囲内の *すべての秒数* とを比較しようとするからです:

	<ruby>
	Client.where(["created_at IN (?)",
	  (params[:start_date].to_date.to_time)..(params[:end_date].to_date.to_time)])
	</ruby>

	<sql>
	SELECT * FROM users WHERE (created_at IN
	  ('2007-12-01 00:00:00', '2007-12-01 00:00:01' ...
	  '2007-12-01 23:59:59', '2007-12-02 00:00:00'))
	</sql>

.EN	This could possibly cause your database server to raise an unexpected error, for example MySQL will throw back this error:
.JA	これは、データベースサーバに予期せぬエラーを発生させる可能性があります。たとえば MySQL だと次のようなエラーが返されます:

.EN	<shell>
.EN	Got a packet bigger than 'max_allowed_packet' bytes: _query_
.EN	</shell>

.EN	Where _query_ is the actual query used to get that error.
.JA	ここで _query_ はエラーを引き起こした実際のクエリです。

.EN	In this example it would be better to use greater-than and less-than operators in SQL, like so:
.JA	この例では SQL の演算子である「>」や「<」を使うほうがいいでしょう。たとえば:

	<ruby>
	Client.where(
	  ["created_at > ? AND created_at < ?", params[:start_date], params[:end_date]])
	</ruby>

.EN	You can also use the greater-than-or-equal-to and less-than-or-equal-to like this:
.JA	もちろん Ruby と同じように、「>=」や「<=」も利用できます:

.EN	<ruby>
.EN	Client.where(
.EN	  ["created_at >= ? AND created_at <= ?", params[:start_date], params[:end_date]])
.EN	</ruby>

.EN	Just like in Ruby. If you want a shorter syntax be sure to check out the "Hash Conditions":#hash-conditions section later on in the guide.
.JA	もしより短いシンタックスを望むなら、次のセクション「ハッシュを使った検索条件」を読むことを強くお勧めします。

.EN	h4. Hash Conditions
.JA	h4. ハッシュを使った検索条件

.EN	Active Record also allows you to pass in a hash conditions which can increase the readability of your conditions syntax. With hash conditions, you pass in a hash with keys of the fields you want conditionalised and the values of how you want to conditionalise them:
.JA	Active Record では、Hash による検索条件 (Hash Conditions) を使うことができます。これを使うと、条件式の可読性が向上します。Hash による検索条件を使うことで、条件式で使いたいフィールド名をキーとし、条件として使いたい値を Hash の値に指定できます:

.EN	NOTE: Only equality, range and subset checking are possible with Hash conditions.
.JA	NOTE: 同様に、範囲式やサブセットチェック (subset checking)〔訳注: ???〕も Hash による検索条件で利用可能です。

.EN	h5. Equality Conditions
.JA	h5. 等号による検索条件

	<ruby>
	Client.where({ :locked => true })
	</ruby>

.EN	The field name does not have to be a symbol it can also be a string:
.JA	フィールド名は Symbol である必要はなく、String でもよいです:

	<ruby>
	Client.where({ 'locked' => true })
	</ruby>

.EN	h5(#hash-range_conditions). Range Conditions
.JA	h5(#hash-range_conditions). Range を使った検索条件

.EN	The good thing about this is that we can pass in a range for our fields without it generating a large query as shown in the preamble of this section.
.JA	Hash による検索条件のよいところは、フィールドの Range オブジェクトを渡した場合に、前のセクションで見たような巨大なクエリを生成しないという点です。

	<ruby>
	Client.where({ :created_at => (Time.now.midnight - 1.day)..Time.now.midnight})
	</ruby>

.EN	This will find all clients created yesterday by using a +BETWEEN+ SQL statement:
.JA	この場合だと、昨日作成されたすべての顧客情報を、SQL 文の BETWEEN を使って検索します:

	<sql>
	SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
	</sql>

.EN	This demonstrates a shorter syntax for the examples in "Array Conditions":#array-conditions
.JA	このデモンストレーションは、配列による検索条件よりも短く書ける例となっています。

.EN	h5. Subset Conditions
.JA	h5. 部分集合による検索条件

.EN	If you want to find records using the +IN+ expression you can pass an array to the conditions hash:
.JA	もし +IN+ 演算子を使ってレコードを検索したいなら、ハッシュの値に配列を渡せばよいです:

	<ruby>
	Client.where({ :orders_count => [1,3,5] })
	</ruby>

.EN	This code will generate SQL like this:
.JA	この場合なら次のような SQL が生成されます:

	<sql>
	SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
	</sql>

.EN	h4. Ordering
.JA	h4. 順序

.EN	To retrieve records from the database in a specific order, you can specify the +:order+ option to the +find+ call.
.JA	データベースからある特定の順番でレコードを抽出するには、+:order+ オプションつきで +find+ メソッドを呼び出します。

.EN	For example, if you're getting a set of records and want to order them in ascending order by the +created_at+ field in your table:
.JA	たとえば、+created_at+ フィールドの昇順でテーブルからレコードを取り出したいなら:

.EN	<ruby>
.EN	Client.order("created_at")
.EN	</ruby>

.EN	You could specify +ASC+ or +DESC+ as well:
.JA	ASC〔訳注: 昇順〕または DESC〔訳注: 降順〕を指定できます:

	<ruby>
	Client.order("created_at DESC")
.EN	# OR
.JA	# または
	Client.order("created_at ASC")
	</ruby>

.EN	Or ordering by multiple fields:
.JA	あるいは複数のフィールドを指定して:

	<ruby>
	Client.order("orders_count ASC, created_at DESC")
	</ruby>

.EN	h4. Selecting Specific Fields
.JA	h4. 特定のフィールドだけを選択する

.EN	By default, <tt>Model.find</tt> selects all the fields from the result set using +select *+.
.JA	デフォルトでは、<tt>Model.find</tt> は +select *+を使って結果セット (result set) からすべてのフィールドを選択します。

.EN	To select only a subset of fields from the result set, you can specify the subset via the +select+ method.
.JA	結果セットから一部のフィールドだけを取り出すには、select メソッドでフィールド名を指定する必要があります。

.EN	NOTE: If the +select+ method is used, all the returning objects will be "read only":#readonly-objects.
.JA	NOTE: select メソッドが使われると、返されるオブジェクトはすべて "読み取り専用":#readonly-objects 〔訳注: 変更ができない〕になります。

	<br />

.EN	For example, to select only +viewable_by+ and +locked+ columns:
.JA	たとえば、 +viewable_by+ カラムと +locked+ カラムのみを選択するには:

	<ruby>
	Client.select("viewable_by, locked")
	</ruby>

.EN	The SQL query used by this find call will be somewhat like:
.JA	この find メソッド呼び出しによって生成される SQL クエリはだいたい次の通りです:

	<sql>
	SELECT viewable_by, locked FROM clients
	</sql>

.EN	Be careful because this also means you're initializing a model object with only the fields that you've selected. If you attempt to access a field that is not in the initialized record you'll receive:
.JA	モデルオブジェクトのうち、指定されたフィールドのみが初期化されることに注意してください。もし初期化されてないフィールドにアクセスすると、次のようなエラーになります:

.EN	<shell>
.EN	ActiveRecord::MissingAttributeError: missing attribute: <attribute>
.EN	</shell>

.EN	Where +&lt;attribute&gt;+ is the attribute you asked for. The +id+ method will not raise the +ActiveRecord::MissingAttributeError+, so just be careful when working with associations because they need the +id+ method to function properly.
.JA	ここで +&lt;attribute&gt;+ はアクセスしようとしている属性です。+id+ メソッドは +ActiveRecord::MissingAttributeError+ を発生させませんが、アソシエーションは id メソッドが正しく機能することが必要なので、 +id+ メソッドを使う場合は注意してください。

.EN	You can also call SQL functions within the select option. For example, if you would like to only grab a single record per unique value in a certain field by using the +DISTINCT+ function you can do it like this:
.JA	また select オプション内で SQL 関数を指定することができます。たとえば、 +DISTINCT+ 関数を使うことであるフィールドにおける一意な値ごとに 1 つのレコードのみを取り出したいなら、次のようにします:

	<ruby>
	Client.select("DISTINCT(name)")
	</ruby>

.EN	h4. Limit and Offset
.JA	h4. Limit と Offset

.EN	To apply +LIMIT+ to the SQL fired by the +Model.find+, you can specify the +LIMIT+ using +limit+ and +offset+ methods on the relation.
.JA	+Model.find+ メソッドで SQL フィールドに +LIMIT+ を適用するには、+limit+ および +offset+ メソッドをリレーションに指定します。

.EN	If you want to limit the amount of records to a certain subset of all the records retrieved you usually use +limit+ for this, sometimes coupled with +offset+. Limit is the maximum number of records that will be retrieved from a query, and offset is the number of records it will start reading from from the first record of the set. For example:
.JA	もし抽出される全レコードのうち、レコードの総数を制限したサブセットのみを取り出したい場合、 +limit+ オプションと、必要ならば +offset+ オプションも使用します。 Limit オプションはクエリから抽出されるレコードの最大数を表し、offset オプションは抽出されたレコードセットの読み取り開始場所を指定します。たとえば:

	<ruby>
	Client.limit(5)
	</ruby>

.EN	This code will return a maximum of 5 clients and because it specifies no offset it will return the first 5 clients in the table. The SQL it executes will look like this:
.JA	このコードは最大で 5 個の Client オブジェクトを返します。また offset オプションが指定されてないので、テーブルの最初から数えて 5 番目までを返します。上のコードは次のような SQL を実行します:

.EN	<sql>
.EN	SELECT * FROM clients LIMIT 5
.EN	</sql>

.EN	Or chaining both +limit+ and +offset+:
.JA	あるいは +limit+ と +offset+ の両方を指定するには:

	<ruby>
	Client.limit(5).offset(5)
	</ruby>

.EN	This code will return a maximum of 5 clients and because it specifies an offset this time, it will return these records starting from the 5th client in the clients table. The SQL looks like:
.JA	このコードは最大で 5 個の Client オブジェクトを返しますが、今回は offset が指定されているので、clients テーブルにおいて 5 番目のレコードから開始します。SQL は次の通りです:

	<sql>
	SELECT * FROM clients LIMIT 5, 5
	</sql>

.EN	h4. Group
.JA	h4. Group

.EN	To apply +GROUP BY+ clause to the SQL fired by the finder, you can specify the +group+ method on the find.
.JA	検索用メソッドで実行される SQL に +GROUP BY+ を適用するには、 +group+ メソッドを指定します。

.EN	For example, if you want to find a collection of the dates orders were created on:
.JA	たとえば、すべての日付を取り出し、かつ日付順でソートしたい場合:

	<ruby>
	Order.group("date(created_at)").order("created_at")
	</ruby>

.EN	And this will give you a single +Order+ object for each date where there are orders in the database.
.JA	この場合なら、データベース内の日付順で、各日付ごとに +Order+ オブジェクトをひとつ返します。

.EN	The SQL that would be executed would be something like this:
.JA	実行される SQL は次のようなものになります:

	<sql>
	SELECT * FROM orders GROUP BY date(created_at)
	</sql>

.EN	h4. Having
.JA	h4. Having

.EN	SQL uses +HAVING+ clause to specify conditions on the +GROUP BY+ fields. You can specify the +HAVING+ clause to the SQL fired by the +Model.find+ using +:having+ option on the find.
.JA	+GROUP BY+ で指定したフィールドに対する条件は、SQL では +HAVING+ 句で指定します。 +Model.find+ の +:having+ オプションを使うと、SQL での +HAVING+ 句を指定できます。

.EN	For example:
.JA	たとえば:

	<ruby>
	Order.group("date(created_at)".having(["created_at > ?", 1.month.ago])
	</ruby>

.EN	The SQL that would be executed would be something like this:
.JA	実行される SQL は次のようなものになります:

	<sql>
	SELECT * FROM orders GROUP BY date(created_at) HAVING created_at > '2009-01-15'
	</sql>

.EN	This will return single order objects for each day, but only for the last month.
.JA	この例だと各日付ごとに Order オブジェクトをひとつ返しますが、日付が条件を満たす場合のみです。

.EN	h4. Readonly Objects
.JA	h4. 読み取り専用オブジェクト

.EN	To explicitly disallow modification/destruction of the matching records returned in a Relation object, you could chain the +readonly+ method as +true+ to the find call.
.JA	リレーションによって返されたレコードが変更されたり破壊されるのを明示的に防ぐには、 +readonly+ メソッドに +true+ を指定しておいてから、find の呼び出しを繋げます。

.EN	Any attempt to alter or destroy the readonly records will not succeed, raising an +ActiveRecord::ReadOnlyRecord+ exception. To set this option, specify it like this:
.JA	読取専用レコードに対して変更や削除を行うことはできず、例外 +ActiveRecord::ReadOnlyRecord+ が発生します。このオプションを指定するには、次のようにしてください:

	<ruby>
	Client.first.readonly(true)
	</ruby>

.EN	If you assign this record to a variable client, calling the following code will raise an +ActiveRecord::ReadOnlyRecord+ exception:
.JA	もしこのレコードを変数 client に代入して、次のようなコードを実行すると、 +ActiveRecord::ReadOnlyRecord+ 例外が発生します:

	<ruby>
	client = Client.first.readonly(true)
	client.locked = false
	client.save
	</ruby>

.EN	h4. Locking Records for Update
.JA	h4. 更新用にレコードをロックする

.EN	Locking is helpful for preventing the race conditions when updating records in the database and ensuring atomic updated. Active Record provides two locking mechanism:
.JA	ロックは、データベース中のレコードを更新するときに競合条件 (Race condition) を避けるのに役立ちます。また更新をアトミックに行うことも保証してくれます。 Active Record は 2 種類のロックメカニズムを提供しています:

.EN	* Optimistic Locking
.EN	* Pessimistic Locking
.JA	* 楽観的ロック
.JA	* 悲観的ロック

.EN	h5. Optimistic Locking
.JA	h5. 楽観的ロック

.EN	Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data.  It does this by checking whether another process has made changes to a record since it was opened. An +ActiveRecord::StaleObjectError+ exception is thrown if that has occurred and the update is ignored.
.JA	楽観的ロックは、複数のユーザが同じレコードに更新のためにアクセスする場合において、データの衝突 (conflict) があまりないことを仮定した方法です。この方法では、対象レコードを取り出して以降、〔訳注: 更新する際に〕他のプロセスがそのレコードに対して変更を行ったかどうかをチェックします。もし〔訳注: 他プロセスによる変更が〕行われていた場合は +ActiveRecord::StaleObjectError+ が発生し、更新は行われません。

.EN	<strong>Optimistic locking column</strong>
.JA	<strong>楽観的ロック用のカラム</strong>

.EN	In order to use optimistic locking, the table needs to have a column called +lock_version+. Each time the record is updated, Active Record increments the +lock_version+ column and the locking facilities ensure that records instantiated twice will let the last one saved raise an +ActiveRecord::StaleObjectError+ exception if the first was also updated. Example:
.JA	楽観的ロッックを使用する場合、 +lock_version+ という名前のカラムがテーブルに必要です。レコードが更新されるたびに、Active Record は +lock_version+ カラムの値を 1 増やします。こうすることでロック機構は、同じレコードが 2 度インスタンス化されてかつ最初のほうが更新された場合、2 つめのほうがセーブされたときに +ActiveRecord::StaleObjectError+ 例外を必ず発生させます。

	<ruby>
	c1 = Client.find(1)
	c2 = Client.find(1)

	c1.name = "Michael"
	c1.save

	c2.name = "should fail"
.EN	c2.save # Raises a ActiveRecord::StaleObjectError
.JA	c2.save # ActiveRecord::StaleObjectError 例外が発生する
	</ruby>

.EN	You're then responsible for dealing with the conflict by rescuing the exception and either rolling back, merging, or otherwise apply the business logic needed to resolve the conflict.
.JA	更新が衝突したときに、例外を rescue して、ロールバックしたり更新をマージしたりあるいは衝突を解消する何らかのビジネスロジックを実行するのは、開発者の仕事となります。

.EN	NOTE: You must ensure that your database schema defaults the +lock_version+ column to +0+.
.JA	NOTE: データベーススキーマで、 +lock_version+ カラムのデフォルトが +0+ になっていることを確認してください。

	<br />

.EN	This behavior can be turned off by setting <tt>ActiveRecord::Base.lock_optimistically = false</tt>.
.JA	この挙動は <tt>ActiveRecord::Base.lock_optimistically = false</tt> によってオフにすることができます。

.EN	To override the name of the +lock_version+ column, +ActiveRecord::Base+ provides a class method called +set_locking_column+:
.JA	+lock_version+ カラムの名前を変更するために、+ActiveRecord::Base+ は +set_locking_column+ というメソッドを用意しています:

	<ruby>
	class Client < ActiveRecord::Base
	  set_locking_column :lock_client_column
	end
	</ruby>

.EN	h5. Pessimistic Locking
.JA	h5. 悲観的ロック

.EN	Pessimistic locking uses locking mechanism provided by the underlying database. Passing +:lock => true+ to +Model.find+ obtains an exclusive lock on the selected rows. +Model.find+ using +:lock+ are usually wrapped inside a transaction for preventing deadlock conditions.
.JA	悲観的ロックは、データベースが持っている機能を使ったロックメカニズムです。 +Model.find+ を +:lock => true+ に渡すことで、選択された行に排他的ロックをかけることができます。 +:lock+ つきの +Model.find+ は通常、デッドロック条件を防ぐためにトランザクション内で使用されます。

.EN	For example:
.JA	たとえば:

	<ruby>
	Item.transaction do
	  i = Item.first(:lock => true)
	  i.name = 'Jones'
	  i.save
	end
	</ruby>

.EN	The above session produces the following SQL for a MySQL backend:
.JA	このセッションは次のような SQL を生成します (MySQL の場合):

	<sql>
	SQL (0.2ms)   BEGIN
	Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
	Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
	SQL (0.8ms)   COMMIT
	</sql>

.EN	You can also pass raw SQL to the +:lock+ option to allow different types of locks. For example, MySQL has an expression called +LOCK IN SHARE MODE+ where you can lock a record but still allow other queries to read it. To specify this expression just pass it in as the lock option:
.JA	また +:lock+ オプションには生の SQL を渡すことで別の種類のロックを使うこともできます。たとえば MySQL には +LOCK IN SHARE MODE+ という式があり、これはレコードにロックをかけるけど他のユーザがクエリで読み取ることは許すというものです。この式を指定するには、lock オプションにその式をそのまま渡します:

	<ruby>
	Item.transaction do
	  i = Item.find(1, :lock => "LOCK IN SHARE MODE")
	  i.increment!(:views)
	end
	</ruby>

.EN	h3. Joining Tables

.EN	<tt>Model.find</tt> provides a +:joins+ option for specifying +JOIN+ clauses on the resulting SQL. There multiple different ways to specify the +:joins+ option:

.EN	h4. Using a String SQL Fragment

.EN	You can just supply the raw SQL specifying the +JOIN+ clause to the +:joins+ option. For example:

.EN	<ruby>
.EN	Client.all(:joins => 'LEFT OUTER JOIN addresses ON addresses.client_id = clients.id')
.EN	</ruby>

.EN	This will result in the following SQL:

.EN	<sql>
.EN	SELECT clients.* FROM clients LEFT OUTER JOIN addresses ON addresses.client_id = clients.id
.EN	</sql>

.EN	h4. Using Array/Hash of Named Associations

.EN	WARNING: This method only works with +INNER JOIN+,

.EN	<br />

.EN	Active Record lets you use the names of the "associations":association_basics.html defined on the model as a shortcut for specifying the +:joins+ option.

.EN	For example, consider the following +Category+, +Post+, +Comments+ and +Guest+ models:

.EN	<ruby>
.EN	class Category < ActiveRecord::Base
.EN	  has_many :posts
.EN	end

.EN	class Post < ActiveRecord::Base
.EN	  belongs_to :category
.EN	  has_many :comments
.EN	  has_many :tags
.EN	end

.EN	class Comments < ActiveRecord::Base
.EN	  belongs_to :post
.EN	  has_one :guest
.EN	end

.EN	class Guest < ActiveRecord::Base
.EN	  belongs_to :comment
.EN	end
.EN	</ruby>

.EN	Now all of the following will produce the expected join queries using +INNER JOIN+:

.EN	h5. Joining a Single Association

.EN	<ruby>
.EN	Category.joins(:posts)
.EN	</ruby>

.EN	This produces:

.EN	<sql>
.EN	SELECT categories.* FROM categories
.EN	  INNER JOIN posts ON posts.category_id = categories.id
.EN	</sql>

.EN	h5. Joining Multiple Associations

.EN	<ruby>
.EN	Post.joins(:category, :comments)
.EN	</ruby>

.EN	This produces:

.EN	<sql>
.EN	SELECT posts.* FROM posts 
.EN	  INNER JOIN categories ON posts.category_id = categories.id
.EN	  INNER JOIN comments ON comments.post_id = posts.id
.EN	</sql>

.EN	h5. Joining Nested Associations (Single Level)

.EN	<ruby>
.EN	Post.joins(:comments => :guest)
.EN	</ruby>

.EN	h5. Joining Nested Associations (Multiple Level)

.EN	<ruby>
.EN	Category.joins(:posts => [{:comments => :guest}, :tags])
.EN	</ruby>

.EN	h4. Specifying Conditions on the Joined Tables

.EN	You can specify conditions on the joined tables using the regular "Array":#array-conditions and "String":#pure-string-conditions conditions. "Hash conditions":#hash-conditions provides a special syntax for specifying conditions for the joined tables:

.EN	<ruby>
.EN	time_range = (Time.now.midnight - 1.day)..Time.now.midnight
.EN	Client.joins(:orders).where('orders.created_at' => time_range)
.EN	</ruby>

.EN	An alternative and cleaner syntax to this is to nest the hash conditions:

.EN	<ruby>
.EN	time_range = (Time.now.midnight - 1.day)..Time.now.midnight
.EN	Client.joins(:orders).where(:orders => {:created_at => time_range})
.EN	</ruby>

.EN	This will find all clients who have orders that were created yesterday, again using a +BETWEEN+ SQL expression.

.EN	h3. Eager Loading Associations

.EN	Eager loading is the mechanism for loading the associated records of the objects returned by +Model.find+ using as few queries as possible.

.EN	<strong>N <plus> 1 queries problem</strong>

.EN	Consider the following code, which finds 10 clients and prints their postcodes:

.EN	<ruby>
.EN	clients = Client.all(:limit => 10)

.EN	clients.each do |client|
.EN	  puts client.address.postcode
.EN	end
.EN	</ruby>

.EN	This code looks fine at the first sight. But the problem lies within the total number of queries executed. The above code executes 1 ( to find 10 clients ) <plus> 10 ( one per each client to load the address ) = <strong>11</strong> queries in total.

.EN	<strong>Solution to N <plus> 1 queries problem</strong>

.EN	Active Record lets you specify all the associations in advanced that are going to be loaded. This is possible by specifying the +includes+ method of the +Model.find+ call. With +includes+, Active Record ensures that all the specified associations are loaded using minimum possible number of queries.

.EN	Revisiting the above case, we could rewrite +Client.all+ to use eager load addresses:

.EN	<ruby>
.EN	clients = Client.includes(:address).limit(10)

.EN	clients.each do |client|
.EN	  puts client.address.postcode
.EN	end
.EN	</ruby>

.EN	The above code will execute just <strong>2</strong> queries, as opposed to <strong>11</strong> queries in the previous case:

.EN	<sql>
.EN	SELECT * FROM clients LIMIT 10
.EN	SELECT addresses.* FROM addresses
.EN	  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
.EN	</sql>

.EN	h4. Eager Loading Multiple Associations

.EN	Active Record lets you eager load any possible number of associations with a single +Model.find+ call by using an array, hash, or a nested hash of array/hash with the +includes+ method.

.EN	h5. Array of Multiple Associations 

.EN	<ruby>
.EN	Post.includes(:category, :comments)
.EN	</ruby>

.EN	This loads all the posts and the associated category and comments for each post.

.EN	h5. Nested Associations Hash

.EN	<ruby>
.EN	Category.find(1).includes(:posts => [{:comments => :guest}, :tags])
.EN	</ruby>

.EN	The above code finds the category with id 1 and eager loads all the posts associated with the found category. Additionally, it will also eager load every posts' tags and comments. Every comment's guest association will get eager loaded as well.

.EN	h4. Specifying Conditions on Eager Loaded Associations

.EN	Even though Active Record lets you specify conditions on the eager loaded associations just like +joins+, the recommended way is to use "joins":#joining-tables instead. 

.EN	h3. Dynamic Finders

.EN	For every field (also known as an attribute) you define in your table, Active Record provides a finder method. If you have a field called +name+ on your +Client+ model for example, you get +find_by_name+ and +find_all_by_name+ for free from Active Record. If you have also have a +locked+ field on the +Client+ model, you also get +find_by_locked+ and +find_all_by_locked+.

.EN	You can do +find_last_by_*+ methods too which will find the last record matching your argument.

.EN	You can specify an exclamation point (<tt>!</tt>) on the end of the dynamic finders to get them to raise an +ActiveRecord::RecordNotFound+ error if they do not return any records, like +Client.find_by_name!("Ryan")+

.EN	If you want to find both by name and locked, you can chain these finders together by simply typing +and+ between the fields for example +Client.find_by_name_and_locked("Ryan", true)+.


.EN	There's another set of dynamic finders that let you find or create/initialize objects if they aren't found. These work in a similar fashion to the other finders and can be used like +find_or_create_by_name(params[:name])+. Using this will firstly perform a find and then create if the find returns +nil+. The SQL looks like this for +Client.find_or_create_by_name("Ryan")+:

.EN	<sql>
.EN	SELECT * FROM clients WHERE (clients.name = 'Ryan') LIMIT 1
.EN	BEGIN
.EN	INSERT INTO clients (name, updated_at, created_at, orders_count, locked)
.EN	  VALUES('Ryan', '2008-09-28 15:39:12', '2008-09-28 15:39:12', 0, '0')
.EN	COMMIT
.EN	</sql>

.EN	+find_or_create+'s sibling, +find_or_initialize+, will find an object and if it does not exist will act similar to calling +new+ with the arguments you passed in. For example:

.EN	<ruby>
.EN	client = Client.find_or_initialize_by_name('Ryan')
.EN	</ruby>

.EN	will either assign an existing client object with the name "Ryan" to the client local variable, or initialize a new object similar to calling +Client.new(:name => 'Ryan')+. From here, you can modify other fields in client by calling the attribute setters on it: +client.locked = true+ and when you want to write it to the database just call +save+ on it.

.EN	h3. Finding by SQL

.EN	If you'd like to use your own SQL to find records in a table you can use +find_by_sql+. The +find_by_sql+ method will return an array of objects even if the underlying query returns just a single record. For example you could run this query:

.EN	<ruby>
.EN	Client.find_by_sql("SELECT * FROM clients 
.EN	  INNER JOIN orders ON clients.id = orders.client_id 
.EN	  ORDER clients.created_at desc")
.EN	</ruby>

.EN	+find_by_sql+ provides you with a simple way of making custom calls to the database and retrieving instantiated objects.

.EN	h3. +select_all+

.EN	<tt>find_by_sql</tt> has a close relative called +connection#select_all+. +select_all+ will retrieve objects from the database using custom SQL just like +find_by_sql+ but will not instantiate them. Instead, you will get an array of hashes where each hash indicates a record.

.EN	<ruby>
.EN	Client.connection.select_all("SELECT * FROM clients WHERE id = '1'")
.EN	</ruby>

.EN	h3. Existence of Objects

.EN	If you simply want to check for the existence of the object there's a method called +exists?+. This method will query the database using the same query as +find+, but instead of returning an object or collection of objects it will return either +true+ or +false+.

.EN	<ruby>
.EN	Client.exists?(1)
.EN	</ruby>

.EN	The +exists?+ method also takes multiple ids, but the catch is that it will return true if any one of those records exists.

.EN	<ruby>
.EN	Client.exists?(1,2,3)
.EN	# or
.EN	Client.exists?([1,2,3])
.EN	</ruby>

.EN	Further more, +exists+ takes a +conditions+ option much like find:

.EN	<ruby>
.EN	Client.exists?(:conditions => "first_name = 'Ryan'")
.EN	</ruby>

.EN	It's even possible to use +exists?+ without any arguments:

.EN	<ruby>
.EN	Client.exists?
.EN	</ruby>

.EN	The above returns +false+ if the +clients+ table is empty and +true+ otherwise.

.EN	h3. Calculations

.EN	This section uses count as an example method in this preamble, but the options described apply to all sub-sections.

.EN	<tt>count</tt> takes conditions much in the same way +exists?+ does:

.EN	<ruby>
.EN	Client.count(:conditions => "first_name = 'Ryan'")
.EN	</ruby>

.EN	Which will execute:

.EN	<sql>
.EN	SELECT count(*) AS count_all FROM clients WHERE (first_name = 'Ryan')
.EN	</sql>

.EN	You can also use the +includes+ or +joins+ methods for this to do something a little more complex:

.EN	<ruby>
.EN	Client.count.where("clients.first_name = 'Ryan' AND orders.status = 'received'").includes("orders")
.EN	</ruby>

.EN	Which will execute:

.EN	<sql>
.EN	SELECT count(DISTINCT clients.id) AS count_all FROM clients
.EN	  LEFT OUTER JOIN orders ON orders.client_id = client.id WHERE
.EN	  (clients.first_name = 'Ryan' AND orders.status = 'received')
.EN	</sql>

.EN	This code specifies +clients.first_name+ just in case one of the join tables has a field also called +first_name+ and it uses +orders.status+ because that's the name of our join table.

.EN	h4. Count

.EN	If you want to see how many records are in your model's table you could call +Client.count+ and that will return the number. If you want to be more specific and find all the clients with their age present in the database you can use +Client.count(:age)+.

.EN	For options, please see the parent section, "Calculations":#calculations.

.EN	h4. Average

.EN	If you want to see the average of a certain number in one of your tables you can call the +average+ method on the class that relates to the table. This method call will look something like this:

.EN	<ruby>
.EN	Client.average("orders_count")
.EN	</ruby>

.EN	This will return a number (possibly a floating point number such as 3.14159265) representing the average value in the field.

.EN	For options, please see the parent section, "Calculations":#calculations.

.EN	h4. Minimum

.EN	If you want to find the minimum value of a field in your table you can call the +minimum+ method on the class that relates to the table. This method call will look something like this:

.EN	<ruby>
.EN	Client.minimum("age")
.EN	</ruby>

.EN	For options, please see the parent section, "Calculations":#calculations.

.EN	h4. Maximum

.EN	If you want to find the maximum value of a field in your table you can call the +maximum+ method on the class that relates to the table. This method call will look something like this:

.EN	<ruby>
.EN	Client.maximum("age")
.EN	</ruby>

.EN	For options, please see the parent section, "Calculations":#calculations.

.EN	h4. Sum

.EN	If you want to find the sum of a field for all records in your table you can call the +sum+ method on the class that relates to the table. This method call will look something like this:

.EN	<ruby>
.EN	Client.sum("orders_count")
.EN	</ruby>

.EN	For options, please see the parent section,  "Calculations":#calculations.

.EN	h3. Changelog

.EN	"Lighthouse ticket":http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/16

.EN	* April 7, 2010: Fixed document to validate XHTML 1.0 Strict. "Jaime Iniesta":http://jaimeiniesta.com
.EN	* February 3, 2010: Update to Rails 3 by "James Miller":credits.html#bensie
.EN	* February 7, 2009: Second version by "Pratik":credits.html#lifo
.EN	* December 29 2008: Initial version by "Ryan Bigg":credits.html#radar
